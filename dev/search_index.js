var documenterSearchIndex = {"docs":
[{"location":"#DynamicGrids.jl-1","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"DynamicGrids","category":"page"},{"location":"#DynamicGrids","page":"DynamicGrids.jl","title":"DynamicGrids","text":"DynamicGrids\n\n(Image: ) (Image: ) (Image: Build Status)  (Image: Coverage Status)  (Image: codecov.io)\n\nDynamicGrids is a generalised framework for building high-performance grid-based spatial models, including celluar automata, but also allowing arbitrary behviours such as long distance jumps and interactions between multiple grids. It is extended by Dispersal.jl for modelling organism dispersal processes.\n\n(Image: Dispersal quarantine)\n\nA dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the  GtkOuput from DynamicGridsGtk.  Note that this is indicative of the real-time frame-rate on a laptop.\n\nA DynamicGrids.jl simulation is run with a script like this one running the included game of life model Life():\n\nusing DynamicGrids, Crayons\ninit = rand(Bool, 150, 200)\noutput = REPLOutput(init; fps=30, color=Crayon(foreground=:red, background=:black, bold=true))\nruleset = Ruleset(Life(); init=init)\nsim!(output, ruleset; tspan=(1, 200))\n\n(Image: REPL life)\n\nA game of life simulation being displayed directly in a terminal.\n\nConcepts\n\nThe framework is highly customisable, but there are some central ideas that define how a simulation works: rules and interactions, init arrays and outputs.\n\nRules\n\nRules hold the parameters for running a simulation. Each rule triggers a specific applyrule method that operates on each of the active cells in the grid. Rules come in a number of flavours (outlined in the  docs), which allow assumptions to be made about running them that can greatly improve performance. Rules are joined in a Ruleset object and run in sequence:\n\nruleset = Ruleset(Life(2, 3))\n\nThe Ruleset wrapper seems a little redundant here, but multiple models can be combined in a Ruleset. Each rule will be run for the whole grid, in sequence, using appropriate optimisations depending on the parent types of each rule:\n\nruleset = Ruleset(rule1, rule2)\n\nFor better performance (often ~2x), models included in a Chain object will be combined into a single model, using only one array read and write. This optimisation is limited to CellRule, or a NeighborhoodRule followed by CellRule. If the @inline compiler macro is used on all applyrule methods, all rules in a Chain will be compiled together into a single,  efficient function call.\n\nruleset = Ruleset(rule1, Chain(rule2, rule3, rule4))\n\nA Ruleset can also hold rules that act on multiple grids. These may either run side by side independently (say for live comparative analysis), or interact.\n\nInit\n\nThe init array may be any AbstractArray or a NamedTuple of AbstractArray,  It contains whatever initialisation data is required to start the simulation.  The array type, size and element type of the init array determine the types used in the simulation, as well as providing the initial conditions:\n\ninit = rand(Float32, 100, 100)\n\nAn init array can be attached to a Ruleset: \n\nruleset = Ruleset(Life(); init=init)\n\nor passed into a simulation, where it will take preference over the Ruleset init:\n\nsim!(output, rulset; init=init)\n\nFor multiple grids, init is a NamedTuple of equal-sized arrays matching the names given to each Ruleset :\n\ninit = (predator=rand(100, 100), prey=(rand(100, 100))\n\nHandling and passing of the correct arrays is automated by DynamicGrids.jl. Rules must specify which grids they require in what order, using the first two (R and W) type parameters. \n\nDimensional or spatial init arrays from DimensionalData.jl of GeoData.jl will propagate through the model to return output with explicit dimensions. This will plot correctly as a map using Plots.jl, to which shape files and observation points can be easily added.\n\nOutput\n\nOutputs are ways of storing or viewing a simulation. They can be used interchangeably depending on your needs: ArrayOutput is a simple storage structure for high performance-simulations. As with most outputs, it is initialised with the init array, but in this case it also requires the number of simulation frames to preallocate before the simulation runs.\n\noutput = ArrayOutput(init, 10)\n\nThe REPLOutput shown above is an inbuilt GraphicOutput that can be useful for checking a simulation when working in a terminal or over ssh:\n\noutput = REPLOutput(init)\n\nImageOutput is the most complex class of outputs, allowing full color visual simulations using COlorSchemes.jl. It can also display interactions using color  composites or layouts, as shown above in the quarantine simulation.\n\nDynamicGridsInteract.jl provides simulation interfaces for use in Juno, Jupyter, web pages or electron apps, with live interactive control over parameters. DynamicGridsGtk.jl is a simple graphical output for Gtk. These packages are kept separate to avoid dependencies when being used in non-graphical simulations. \n\nOutputs are also easy to write, and high performance or applications may benefit from writing a custom output to reduce memory use, such as running a loss function on the fly instead of storing the array. Performance of DynamicGrids.jl is dominated by cache interactions, and reducing memory use has significant positive effects. Custom  frame processors can also be written, which can help developing specialised visualisations.\n\nExample\n\nThis example implements a very simple forest fire model:\n\nusing DynamicGrids, DynamicGridsGtk, ColorSchemes, Colors\n\nconst DEAD = 1\nconst ALIVE = 2\nconst BURNING = 3\n\n# Define the Rule struct\nstruct ForestFire{R,W,N,PC,PR} <: NeighborhoodRule{R,W}\n    neighborhood::NH\n    prob_combustion::PC\n    prob_regrowth::PR\nend\nForestFire(; neighborhood=RadialNeighborhood{1}(), prob_combustion=0.0001, prob_regrowth=0.01) =\n    ForestFire(neighborhood, prob_combustion, prob_regrowth)\n\n# Define an [`applyrule`](@ref) method to be broadcasted over the grid for the [`ForestFire`](@ref) rule\n@inline DynamicGrids.applyrule(rule::ForestFire, data, state::Integer, index, hoodbuffer) =\n    if state == ALIVE\n        if BURNING in DynamicGrids.neighbors(rule, hoodbuffer)\n            BURNING\n        else\n            rand() <= rule.prob_combustion ? BURNING : ALIVE\n        end\n    elseif state in BURNING\n        DEAD\n    else\n        rand() <= rule.prob_regrowth ? ALIVE : DEAD\n    end\n\n# Set up the init array, ruleset and output (using a Gtk window)\ninit = fill(ALIVE, 400, 400)\nruleset = Ruleset(ForestFire(); init=init)\nprocessor = ColorProcessor(scheme=ColorSchemes.rainbow, zerocolor=RGB24(0.0))\noutput = GtkOutput(init; fps=25, minval=DEAD, maxval=BURNING, processor=processor)\n\n# Run the simulation\nsim!(output, ruleset; tspan=(1, 200))\n\n# Save the output as a gif\nsavegif(\"forestfire.gif\", output)\n\n\n\n(Image: forestfire)\n\nWe could also use a \"windy\" custom neighborhood:\n\nwindyhood = CustomNeighborhood((1,1), (1,2), (1,3), (2,1), (3,1))\nruleset = Ruleset(ForestFire(; neighborhood=windyhood); init=init)\nsim!(output, ruleset; tspan=(1, 200))\nsavegif(\"windy_forestfire.gif\", output)\n\n(Image: windy_forestfire)\n\nTiming the simulation for 200 steps, the performance is quite good:\n\noutput = ArrayOutput(init, 200)\n@time sim!(output, ruleset; tspan=(1, 200))\n 1.384755 seconds (640 allocations: 2.569 MiB)\n\n# To save a gif of the ArrayOutput we need to pass in a processor and the min and max\n# values used in the simulation:\n\nsavegif(\"forestfire.gif\", output; minval=DEAD, maxval=BURNING, processor=processor)\n\nAlternatives\n\nAgents.jl can also do cellular-automata style simulations. The design of Agents.jl is to iterate over a list of agents, instead of broadcasting over an array of cells. This approach is well suited to when you need to track the movement and details about individual agents throughout the simulation. \n\nHowever, for simple grid models where you don't need to track individuals, like the forest fire model above, DynamicGrids.jl is two orders of magnitude faster than Agents.jl, and provides better visualisation tools. If you are doing grid-based simulation and you don't need to track individual agents, DynamicGrids.jl is probably the best tool. For other use cases, try Agents.jl.\n\n\n\n\n\n","category":"module"},{"location":"#More-Examples-1","page":"DynamicGrids.jl","title":"More Examples","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"While this package isn't designed or optimised specifically to run the game of life, it's a simple demonstration of what it can do. This example runs a game of life and displays it in a REPLOutput.","category":"page"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"using DynamicGrids\n\n# Build a random starting grid\ninit = round.(Int8, max.(0.0, rand(-2.0:0.1:1.0, 70,70)))\n\n# Use the default game of life model\nmodel = Ruleset(Life())\n\n# Use an output that shows the cellular automata as blocks in the REPL\noutput = REPLOutput(init; fps=5)\n\nsim!(output, model; init=init, tspan=(1, 50))","category":"page"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"More life-like examples:","category":"page"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"# Morley\nsim!(output, Ruleset(Life(b=[3,6,8], s=[2,4,5]); init=init))\n\n# 2x2\nsim!(output, Ruleset(Life(b=[3,6], s=[1,2,5]); init=init))\n\n# Dimoeba\ninit1 = round.(Int8, max.(0.0, rand(70,70)))\nsim!(output, Ruleset(Life(b=[3,5,6,7,8], s=[5,6,7,8]); init=init1))\n\n## No death\nsim!(output, Ruleset(Life(b=[3], s=[0,1,2,3,4,5,6,7,8]); init))\n\n## 34 life\nsim!(output, Ruleset(Life(b=[3,4], s=[3,4])); init=init, fps=10)\n\n# Replicator\ninit2 = round.(Int8, max.(0.0, rand(70,70)))\ninit2[:, 1:30] .= 0\ninit2[21:50, :] .= 0\nsim!(output, Ruleset(Life(b=[1,3,5,7], s=[1,3,5,7])); init=init2)","category":"page"},{"location":"#Rules-1","page":"DynamicGrids.jl","title":"Rules","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Rules define simulation behaviour. They hold data relevant to the simulation, and trigger dispatch of particular applyrule or applyrule! methods. Rules can be chained together arbitrarily to make composite simulations across any number of grids.","category":"page"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Ruleset\nRule\nCellRule\nNeighborhoodRule\nPartialRule\nPartialNeighborhoodRule\nMap          \nChain\nLife","category":"page"},{"location":"#DynamicGrids.Ruleset","page":"DynamicGrids.jl","title":"DynamicGrids.Ruleset","text":"Ruleset(rules...; init=nothing, overflow=RemoveOverflow(), cellsize=1, timestep=1)\n\nA container for holding a sequence of Rule, an init array and other simulaiton details.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Rule","page":"DynamicGrids.jl","title":"DynamicGrids.Rule","text":"abstract type Rule\n\nA rule contains all the information required to run a rule in a simulation, given an initial array. Rules can be chained together sequentially.\n\nBy default the output of the rule for a Rule is automatically written to the current cell in the grid.\n\nRules are applied to the grid using the applyrule method.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CellRule","page":"DynamicGrids.jl","title":"DynamicGrids.CellRule","text":"abstract type CellRule <: Rule{R,W}\n\nA Rule that only writes and accesses a single cell: its return value is the new value of the cell(s). This limitation can be useful for performance optimisation, such as wrapping rules in Chain so that no writes occur between rules.\n\nAccessing source(data) and dest(data) arrays directly from CellRule is not guaranteed to have correct results, and should not be done.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.NeighborhoodRule","page":"DynamicGrids.jl","title":"DynamicGrids.NeighborhoodRule","text":"abstract type NeighborhoodRule <: Rule{R,W}\n\nA Rule that only accesses a neighborhood centered around the current cell. NeighborhoodRule is applied with the method:\n\napplyrule(rule::Life, data, state, index, buffer)\n\nFor each cell a neighborhood buffer will be populated containing the neighborhood cells, and passed to applyrule as the extra buffer argmuent.\n\nThis allows memory optimisations and the use of BLAS routines on the neighborhood buffer for RadialNeighborhood. It also means that and no bounds checking is required in neighborhood code, a major performance gain.\n\nneighbors(buffer) returns an iterator over the buffer that is generic to any neigborhood type - Custom shapes as well as square radial neighborhoods.\n\nNeighborhoodRule should read only from the state args and the neighborhood buffer array. The return value is written to the central cell for the next grid frame.\n\nFor neighborhood rules with multiple read grids, the first is the one given a neighborhood buffer.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.PartialRule","page":"DynamicGrids.jl","title":"DynamicGrids.PartialRule","text":"abstract type PartialRule <: Rule{R,W}\n\nPartialRule is for rules that manually write to whichever cells of the grid that they choose, instead of automatically updating every cell with their output.\n\nUpdates to the destination grids data must be performed manually by data[:key] = x. Updating block status is handled automatically on write.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.PartialNeighborhoodRule","page":"DynamicGrids.jl","title":"DynamicGrids.PartialNeighborhoodRule","text":"abstract type PartialNeighborhoodRule <: PartialRule{R,W}\n\nA Rule that only writes to its neighborhood, defined by its radius distance from the current point.\n\nPartialNeighborhood rules must return their radius with a radius() method, although by default this will be called on the result of neighborhood(rule).\n\nTODO: performance optimisations with a neighborhood buffer, simular to NeighborhoodRule but for writing.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Map","page":"DynamicGrids.jl","title":"DynamicGrids.Map","text":"A CellRule that applies a function f to the read grid cells and returns the write cells.\n\nExample\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Chain","page":"DynamicGrids.jl","title":"DynamicGrids.Chain","text":"struct Chain{R, W, T<:Union{Tuple{}, Tuple{Union{#s14, #s13} where #s13<:CellRule where #s14<:NeighborhoodRule,Vararg{CellRule,N} where N}}} <: Rule{R,W}\n\nChains allow chaining rules together to be completed in a single processing step without intermediate reads or writes from grids. They are potentially compiled together into a single function call, especially if you use @inline on all applyrule. methods. Chain can hold either all CellRule or NeighborhoodRule followed by CellRule`.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Life","page":"DynamicGrids.jl","title":"DynamicGrids.Life","text":"Rule for game-of-life style cellular automata. This is a demonstration of  Cellular Automata more than a seriously optimised game of life rule.\n\nCells becomes active if it is empty and the number of neightbors is a number in the b array, and remains active the cell is active and the number of neightbors is in the s array.\n\nReturns: boolean\n\nExamples (gleaned from CellularAutomata.jl)\n\n# Life. \ninit = round.(Int64, max.(0.0, rand(-3.0:0.1:1.0, 300,300)))\noutput = REPLOutput(init; fps=10, color=:red)\nsim!(output, rule, init; tspan=(1, 1000)\n\n# Dimoeba\ninit = rand(0:1, 400, 300)\ninit[:, 100:200] .= 0\noutput = REPLOutput{:braile}(init; fps=25, color=:blue)\nsim!(output, Ruleset(Life(b=(3,5,6,7,8), s=(5,6,7,8))), init; tspan=(1, 1000))\n\n# Replicator\ninit = fill(1, 300,300)\ninit[:, 100:200] .= 0\ninit[10, :] .= 0\noutput = REPLOutput(init; fps=60, color=:yellow)\nsim!(output, Ruleset(Life(b=(1,3,5,7), s=(1,3,5,7))), init; tspan=(1, 1000))\n\nField Description Default Limits\nneighborhood Any Neighborhood nothing nothing\nb Array, Tuple or Iterable of integers to match neighbors when cell is empty nothing (0, 8)\ns Array, Tuple or Iterable of integers to match neighbors cell is full nothing (0, 8)\n\n\n\n\n\n","category":"type"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"applyrule\napplyrule!","category":"page"},{"location":"#DynamicGrids.applyrule","page":"DynamicGrids.jl","title":"DynamicGrids.applyrule","text":"applyrule(rule::Rule, data, state, index, [buffer])\n\nUpdates cell values based on their current state and the  state of other cells as defined in the Rule.\n\nArguments:\n\nrule : Rule\ndata : SimData\nstate: the value(s) of the current cell\nindex: a (row, column) tuple of Int for the current cell coordinates - t: the current time step\nbuffer: a neighborhood burrer array passed to [NeighborhoodRule].\n\nReturns the values) to be written to the current cell(s).\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.applyrule!","page":"DynamicGrids.jl","title":"DynamicGrids.applyrule!","text":"applyrule!(rule::PartialRule, data, state, index)\n\nA rule that manually writes to the grid data array,  used in all rules inheriting from PartialRule.\n\nArguments:\n\nsee applyrule\n\n\n\n\n\n","category":"function"},{"location":"#Neighborhoods-1","page":"DynamicGrids.jl","title":"Neighborhoods","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Neighborhoods define a pattern of cells surrounding the current cell,  and how they are combined to update the value of the current cell.","category":"page"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Neighborhood\nAbstractRadialNeighborhood\nRadialNeighborhood\nAbstractCustomNeighborhood\nCustomNeighborhood\nLayeredCustomNeighborhood","category":"page"},{"location":"#DynamicGrids.Neighborhood","page":"DynamicGrids.jl","title":"DynamicGrids.Neighborhood","text":"abstract type Neighborhood\n\nNeighborhoods define how surrounding cells are related to the current cell. The neighbors function returns the sum of surrounding cells, as defined by the neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.AbstractRadialNeighborhood","page":"DynamicGrids.jl","title":"DynamicGrids.AbstractRadialNeighborhood","text":"abstract type AbstractRadialNeighborhood <: Neighborhood{R}\n\nA Moore-style neighborhood where a square are with a center radius (D - 1) / 2 where D is the diameter.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RadialNeighborhood","page":"DynamicGrids.jl","title":"DynamicGrids.RadialNeighborhood","text":"struct RadialNeighborhood{R} <: AbstractRadialNeighborhood{R}\n\nRadial neighborhoods calculate the surrounding neighborood from the radius around the central cell. The central cell is ommitted.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.AbstractCustomNeighborhood","page":"DynamicGrids.jl","title":"DynamicGrids.AbstractCustomNeighborhood","text":"abstract type AbstractCustomNeighborhood <: Neighborhood{R}\n\nCustom neighborhoods are tuples of custom coordinates (also tuples) specified in relation to the central point of the current cell. They can be any arbitrary shape or size, but should be listed in column-major order for performance.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.CustomNeighborhood","page":"DynamicGrids.jl","title":"DynamicGrids.CustomNeighborhood","text":"Allows completely arbitrary neighborhood shapes by specifying each coordinate specifically.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.LayeredCustomNeighborhood","page":"DynamicGrids.jl","title":"DynamicGrids.LayeredCustomNeighborhood","text":"Sets of custom neighborhoods that can have separate rules for each set.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"neighbors\nsumneighbors\nmapsetneighbor!\nsetneighbor!","category":"page"},{"location":"#DynamicGrids.neighbors","page":"DynamicGrids.jl","title":"DynamicGrids.neighbors","text":"neighbors(hood::Neighborhood, buffer)\n\nReturns an iteraterable over all cells in the neighborhood.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.sumneighbors","page":"DynamicGrids.jl","title":"DynamicGrids.sumneighbors","text":"sumneighbors(hood::Neighborhood, buffer, state)\n\nSums all cells in the neighborhood. This is identical to running  sum(neighbors(hood, buffer)) but it can be more efficient than as it may use matrix algra libraries for sum, instead of regular sum over  an iterator.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.mapsetneighbor!","page":"DynamicGrids.jl","title":"DynamicGrids.mapsetneighbor!","text":"mapsetneighbor!(data, hood, rule, state, index)\n\nRun setneighbors over all cells in the neighborhood and sums its return values. \n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.setneighbor!","page":"DynamicGrids.jl","title":"DynamicGrids.setneighbor!","text":"Set value of a cell in the neighborhood. Called in mapsetneighbor.\n\n\n\n\n\n","category":"function"},{"location":"#Output-1","page":"DynamicGrids.jl","title":"Output","text":"","category":"section"},{"location":"#Output-Types-and-Constructors-1","page":"DynamicGrids.jl","title":"Output Types and Constructors","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Output\nArrayOutput\nGraphicOutput\nREPLOutput\nImageOutput","category":"page"},{"location":"#DynamicGrids.Output","page":"DynamicGrids.jl","title":"DynamicGrids.Output","text":"abstract type Output <: AbstractArray{T,1}\n\nAll outputs must inherit from Output.\n\nSimulation outputs are decoupled from simulation behaviour and in many cases can be used interchangeably.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ArrayOutput","page":"DynamicGrids.jl","title":"DynamicGrids.ArrayOutput","text":"A simple output that stores each step of the simulation in a vector of arrays.\n\nArguments:\n\nframes: Single init array or vector of arrays\nlength: The length of the output.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GraphicOutput","page":"DynamicGrids.jl","title":"DynamicGrids.GraphicOutput","text":"abstract type GraphicOutput <: Output{T}\n\nOutputs that display the simulation frames live.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.REPLOutput","page":"DynamicGrids.jl","title":"DynamicGrids.REPLOutput","text":"An output that is displayed directly in the REPL. It can either store or discard simulation frames.\n\nArguments:\n\nframes: Single init array or vector of arrays\n\nKeyword Arguments:\n\nfps::Real: frames per second to run at\nshowfps::Real: maximum displayed frames per second\nstore::Bool: store frames or not\ncolor: a color from Crayons.jl\ncutoff::Real: the cutoff point to display a full or empty cell. Default is 0.5\nstyle::CharStyle: Block() or Braile() style printing. Braile uses 1/4 the screen space.\n\nREPLOutput(init)\n\nThe default option is :block.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ImageOutput","page":"DynamicGrids.jl","title":"DynamicGrids.ImageOutput","text":"abstract type ImageOutput <: GraphicOutput{T}\n\nGraphic outputs that display the grid(s) as an RGB24 images.\n\nNo ImageOutputs are provided in DynamicGrids.jl to avoid heavey dependencies on graphics libraries. See DynamicGridsGtk.jl and DynamicGridsInteract.jl for implementations.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Dynamic grids uses Mixers.jl mixins to simplify specifying custom outputs with the required fields.","category":"page"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"@Output\n@Graphic\n@Image","category":"page"},{"location":"#DynamicGrids.@Output","page":"DynamicGrids.jl","title":"DynamicGrids.@Output","text":"Mixin of basic fields for all outputs\n\n\n\n\n\n","category":"macro"},{"location":"#DynamicGrids.@Graphic","page":"DynamicGrids.jl","title":"DynamicGrids.@Graphic","text":"Mixin for graphic output fields\n\n\n\n\n\n","category":"macro"},{"location":"#DynamicGrids.@Image","page":"DynamicGrids.jl","title":"DynamicGrids.@Image","text":"Mixin fields for ImageOutputs\n\n\n\n\n\n","category":"macro"},{"location":"#Grid-processors-1","page":"DynamicGrids.jl","title":"Grid processors","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"GridProcessor\nSingleGridProcessor \nColorProcessor\nMultiGridProcessor\nThreeColorProcessor\nLayoutProcessor\nGreyscale","category":"page"},{"location":"#DynamicGrids.GridProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.GridProcessor","text":"abstract type GridProcessor\n\nGrid processors convert a frame of the simulation into an RGB24 image for display. Frames may hold one or multiple grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.SingleGridProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.SingleGridProcessor","text":"abstract type SingleGridProcessor <: GridProcessor\n\nGrid processors that convert one grid to an image.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ColorProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.ColorProcessor","text":"\"     ColorProcessor(; scheme=Greyscale(), zerocolor=nothing, maskcolor=nothing)\n\nConverts output grids to a colorsheme.\n\nArguments / Keyword Arguments\n\nscheme: a ColorSchemes.jl colorscheme.\nzerocolor: an RGB24 color to use when values are zero, or nothing to ignore.\nmaskcolor: an RGB24 color to use when cells are masked, or nothing to ignore.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.MultiGridProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.MultiGridProcessor","text":"abstract type MultiGridProcessor <: GridProcessor\n\nProcessors that convert multiple grids to an image.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ThreeColorProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.ThreeColorProcessor","text":"ThreeColorProcessor(; colors=(Red(), Green(), Blue()), zerocolor=nothing, maskcolor=nothing)\n\nAssigns Red(), Blue(), Green() or nothing to any number of dynamic grids in any order. Duplicate colors will be summed. The final color sums are combined into a composite color image for display.\n\nArguments / Keyword Arguments\n\ncolors: a tuple or Red(), Green(), Blue(), or nothing matching the number of grids.\nzerocolor: an RGB24 color to use when values are zero, or nothing to ignore.\nmaskcolor: an RGB24 color to use when cells are masked, or nothing to ignore.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.LayoutProcessor","page":"DynamicGrids.jl","title":"DynamicGrids.LayoutProcessor","text":"LayoutProcessor(layout::Array, processors)     LayoutProcessor(reshape(layout, length(layout), 1), processors)\n\nArguments / Keyword arguments\n\nlayout: A Vector or Matrix containing the keyes or numbers of grids in the locations to display them. nothing, missing or 0 values will be skipped.\nprocessors: tuple of SingleGridProcessor, one for each grid in the simulation. Can be nothing for unused grids.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.Greyscale","page":"DynamicGrids.jl","title":"DynamicGrids.Greyscale","text":"struct Greyscale{M1, M2}\n\nDefault colorscheme. Better performance than using a Colorschemes.jl scheme as there is no interpolation.\n\n\n\n\n\n","category":"type"},{"location":"#Gifs-1","page":"DynamicGrids.jl","title":"Gifs","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"savegif","category":"page"},{"location":"#DynamicGrids.savegif","page":"DynamicGrids.jl","title":"DynamicGrids.savegif","text":"savegif(filename::String, o::Output, ruleset; [processor=processor(o)], [kwargs...])\n\nWrite the output array to a gif. You must pass a processor keyword argument for any Output objects not in ImageOutput (which allready have a processor attached).\n\nSaving very large gifs may trigger a bug in Imagemagick.\n\n\n\n\n\n","category":"function"},{"location":"#Overflow-1","page":"DynamicGrids.jl","title":"Overflow","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Overflow\nWrapOverflow\nRemoveOverflow","category":"page"},{"location":"#DynamicGrids.Overflow","page":"DynamicGrids.jl","title":"DynamicGrids.Overflow","text":"abstract type Overflow\n\nSingleton types for choosing the grid overflow rule used in inbounds. These determine what is done when a neighborhood or jump extends outside of the grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.WrapOverflow","page":"DynamicGrids.jl","title":"DynamicGrids.WrapOverflow","text":"struct WrapOverflow <: Overflow\n\nWrap cords that overflow boundaries back to the opposite side\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.RemoveOverflow","page":"DynamicGrids.jl","title":"DynamicGrids.RemoveOverflow","text":"struct RemoveOverflow <: Overflow\n\nRemove coords that overflow boundaries\n\n\n\n\n\n","category":"type"},{"location":"#Internal-data-handling-1","page":"DynamicGrids.jl","title":"Internal data handling","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Simdata and Griddata objects are used to manage the simulation and provide rules with any data they need.","category":"page"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"SimData\nGridData\nReadableGridData\nWritableGridData","category":"page"},{"location":"#DynamicGrids.SimData","page":"DynamicGrids.jl","title":"DynamicGrids.SimData","text":"struct SimData{I, D, Ru, STi, CTi, CFr} <: AbstractSimData\n\nSimulation data hold all intermediate arrays, timesteps and frame numbers for the current frame of the siulation.\n\nA simdata object is accessable in applyrule as the second parameter.\n\nMultiple grids can be indexed into using their key. Single grids can be indexed as if SimData is regular array.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.GridData","page":"DynamicGrids.jl","title":"DynamicGrids.GridData","text":"abstract type GridData\n\nSimulation data specific to a singule grid.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.ReadableGridData","page":"DynamicGrids.jl","title":"DynamicGrids.ReadableGridData","text":"Simulation data and storage passed to rules for each timestep.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicGrids.WritableGridData","page":"DynamicGrids.jl","title":"DynamicGrids.WritableGridData","text":"WriteableGridData is passed to rules <: PartialRule, and can be written to directly as an array. This handles updates to block optimisations and writing to the correct source/dest array.\n\n\n\n\n\n","category":"type"},{"location":"#Methods-1","page":"DynamicGrids.jl","title":"Methods","text":"","category":"section"},{"location":"#","page":"DynamicGrids.jl","title":"DynamicGrids.jl","text":"Modules = [DynamicGrids]\nOrder   = [:function]","category":"page"},{"location":"#DynamicGrids.VonNeumannNeighborhood-Tuple{}","page":"DynamicGrids.jl","title":"DynamicGrids.VonNeumannNeighborhood","text":"A convenience wrapper to build a VonNeumann neighborhoods as a CustomNeighborhood.\n\nTODO: variable radius\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.resume!-Tuple{Any,Any}","page":"DynamicGrids.jl","title":"DynamicGrids.resume!","text":"resume!(output, ruleset; tadd=100, kwargs...)\n\nRestart the simulation where you stopped last time. For arguments see sim!. The keyword arg tadd indicates the number of grid frames to add, and of course an init array will not be accepted.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.savegif","page":"DynamicGrids.jl","title":"DynamicGrids.savegif","text":"savegif(filename::String, o::Output, ruleset; [processor=processor(o)], [kwargs...])\n\nWrite the output array to a gif. You must pass a processor keyword argument for any Output objects not in ImageOutput (which allready have a processor attached).\n\nSaving very large gifs may trigger a bug in Imagemagick.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.sim!-Tuple{Any,Any}","page":"DynamicGrids.jl","title":"DynamicGrids.sim!","text":"sim!(output, ruleset; init=nothing, tstpan=(1, length(output)),      fps=fps(output), simdata=nothing, nreplicates=nothing)\n\nRuns the whole simulation, passing the destination aray to the passed in output for each time-step.\n\nArguments\n\noutput: An Output to store grids or display them on the screen.\nruleset: A Rule() containing one ore more Rule. These will each be run in sequence.\n\nKeyword Arguments\n\ninit: the initialisation array. If not passed, the Ruleset must contain an init array.\ntspan: a tuple holding the start and end of the timespan the simulaiton will run for.\nfps: the frames per second to display. Will be taken from the output if not passed in.\nnreplicates: the number of replicates to combine in stochastic simulations\nsimdata: a SimData object. Keeping it between simulations can reduce memory allocation when that is important.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.applyrule-Tuple{Chain,Any,NamedTuple,Any,Vararg{Any,N} where N}","page":"DynamicGrids.jl","title":"DynamicGrids.applyrule","text":"applyrule(rules::Chain, data, state, (i, j))\n\nChained rules. If a Chain of rules is passed to applyrule, run them sequentially for each cell. This can have much beter performance as no writes occur between rules, and they are essentially compiled together into compound rules. This gives correct results only for CellRule, or for a single NeighborhoodRule followed by CellRule.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.combinebands-Tuple{Any,Any}","page":"DynamicGrids.jl","title":"DynamicGrids.combinebands","text":"combinebands(c::Tuple{Vararg{<:BandColor}, acc, xs)\n\nAssign values to color bands given in any order, and output as RGB24.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.grid2image","page":"DynamicGrids.jl","title":"DynamicGrids.grid2image","text":"Convert a grid or named tuple of grids to an RGB24 image, using a GridProcessor\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.hoodsize-Tuple{Neighborhood}","page":"DynamicGrids.jl","title":"DynamicGrids.hoodsize","text":"hoodsize(radius)\n\nGet the size of a neighborhood dimension from its radius, which is always 2r + 1.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.inbounds-Tuple{Tuple,Tuple,Any}","page":"DynamicGrids.jl","title":"DynamicGrids.inbounds","text":"inbounds(x, max, overflow)\n\nCheck grid boundaries for a single coordinate and max value or a tuple of coorinates and max values.\n\nReturns a tuple containing the coordinate(s) followed by a boolean true if the cell is in bounds, false if not.\n\nOverflow of type RemoveOverflow returns the coordinate and false to skip coordinates that overflow outside of the grid. WrapOverflow returns a tuple with the current position or it's wrapped equivalent, and true as it is allways in-bounds.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.initframes!-Tuple{GraphicOutput,Any}","page":"DynamicGrids.jl","title":"DynamicGrids.initframes!","text":"Grids are deleted and reallocated during the simulation, which this allows runs of any length.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.initgrids!-Tuple{Output,Any}","page":"DynamicGrids.jl","title":"DynamicGrids.initgrids!","text":"Grids are preallocated and reused.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.ismasked-Tuple{AbstractSimData,Vararg{Any,N} where N}","page":"DynamicGrids.jl","title":"DynamicGrids.ismasked","text":"Check if a cell is masked, using the passed-in mask grid.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.normalise-Tuple{Any,Number,Number}","page":"DynamicGrids.jl","title":"DynamicGrids.normalise","text":"normalise(x, min, max)\n\nSet a value to be between zero and one, before converting to Color. min and max of nothing are assumed to be 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.precalcrules","page":"DynamicGrids.jl","title":"DynamicGrids.precalcrules","text":"precalcrules(rule, data)\n\nRun any precalculations needed to run a rule for a particular frame, returning new rule objects containing the updates.\n\nThis is a functional approach, rebuilding rules recursively. @set from Setfield.jl can help updating immutable rules.\n\nThe default action is to return the existing rule without change.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.radius","page":"DynamicGrids.jl","title":"DynamicGrids.radius","text":"radius(rule, [key])\n\nReturn the radius of a rule or ruleset if it has one, otherwise zero.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicGrids.radius-Tuple{Ruleset}","page":"DynamicGrids.jl","title":"DynamicGrids.radius","text":"Find the largest radius present in the passed in rules.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.rgb24-Tuple{Any,Any}","page":"DynamicGrids.jl","title":"DynamicGrids.rgb24","text":"rgb24(scheme, val)\n\nConvert a color scheme and value to an RGB24 value.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.rgb24-Tuple{Number}","page":"DynamicGrids.jl","title":"DynamicGrids.rgb24","text":"rgb24(val)\n\nConvert a number, tuple or color to an RGB24 value.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.ruletypes-Tuple{Ruleset}","page":"DynamicGrids.jl","title":"DynamicGrids.ruletypes","text":"Return a tuple of the base types of the rules in the ruleset\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.scale-Tuple{Any,Any,Any}","page":"DynamicGrids.jl","title":"DynamicGrids.scale","text":"scale(x, min, max)\n\nRescale a value between 0 and 1 to be between min and max. This can be used to shrink the range of a colorsheme that is displayed. min and max of nothing are assumed to be 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicGrids.showimage","page":"DynamicGrids.jl","title":"DynamicGrids.showimage","text":"showimage(image, output, f, t)\n\nShow image generated by and GridProcessor in an ImageOutput.\n\n\n\n\n\n","category":"function"}]
}
