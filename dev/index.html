<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CellularAutomataBase.jl · CellularAutomataBase.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CellularAutomataBase.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>CellularAutomataBase.jl</a><ul class="internal"><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#Rules-1">Rules</a></li><li><a class="toctext" href="#Neighborhoods-1">Neighborhoods</a></li><li><a class="toctext" href="#Output-1">Output</a></li><li><a class="toctext" href="#Overflow-1">Overflow</a></li><li class="toplevel"><a class="toctext" href="#Methods-1">Methods</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>CellularAutomataBase.jl</a></li></ul><a class="edit-page" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>CellularAutomataBase.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="CellularAutomataBase.jl-1" href="#CellularAutomataBase.jl-1">CellularAutomataBase.jl</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase" href="#CellularAutomataBase"><code>CellularAutomataBase</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>CellularAutomataBase provides a framework for building grid-based simulations.</p><p>The framework is highly customisable, but there are some central ideas that define how a simulation works: <em>rules</em>, <em>init</em> arrays and <em>outputs</em>.</p><p>Rules hold the configuration for a simulation, and trigger a specific <code>applyrule</code> method that operates on each of the cells in the grid. See <a href="#CellularAutomataBase.AbstractRule"><code>AbstractRule</code></a> and <a href="#CellularAutomataBase.applyrule"><code>applyrule</code></a>. Rules come in a number of flavours, which allows assumptions to be made about running them that can greatly improve performance. Rules are chained together in a <a href="@ref"><code>Ruleset</code></a> object.</p><p>The init array may be any AbstractArray, containing whatever initialisation data is required to start the simulation. The Array type and element type of the init array determine the types used in the simulation, as well as providing the initial conditions.</p><p>Outputs are ways of storing of viewing a simulation, and can be used interchangeably depending on your needs. See <a href="#CellularAutomataBase.AbstractOutput"><code>AbstractOutput</code></a>.</p><p>A typical simulation is run with a script like:</p><pre><code class="language-julia">init = my_array
rules = Ruleset(Life())
output = ArrayOutput(init)

sim!(output, rules; init=init)</code></pre><p>Multiple models can be passed to <a href="#CellularAutomataBase.sim!-Tuple{Any,Any}"><code>sim!</code></a> in a <a href="@ref"><code>Ruleset</code></a>. Each rule will be run for the whole grid, in sequence.</p><pre><code class="language-julia">sim!(output, Ruleset(rule1, rule2); init=init)</code></pre><p>For better performance, models included in a tuple will be combined into a single model (with only one array write). This is limited to <a href="#CellularAutomataBase.AbstractCellRule"><code>AbstractCellRule</code></a>, although <a href="#CellularAutomataBase.AbstractNeighborhoodRule"><code>AbstractNeighborhoodRule</code></a> may be used as the <em>first</em> model in the tuple.</p><pre><code class="language-julia">sim!(output, Rules(rule1, (rule2, rule3)); init=init)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/CellularAutomataBase.jl#L1-L44">source</a></section><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>While this package isn&#39;t designed or optimised specifically to run the game of life, it&#39;s a simple example of what this package can do. This example runs a game of life and displays it in a REPLOutput.</p><pre><code class="language-">using CellularAutomataBase

# Build a random starting grid
init = round.(Int8, max.(0.0, rand(-2.0:0.1:1.0, 70,70)))

# Use the default game of life model
model = Ruleset(Life())

# Use an output that shows the cellular automata as blocks in the REPL
output = REPLOutput{:block}(init; fps=100)

sim!(output, model, init; tstop=5)</code></pre><p>More life-like examples:</p><pre><code class="language-julia"># Morley
sim!(output, Ruleset(Life(b=[3,6,8], s=[2,4,5]); init=init))

# 2x2
sim!(output, Ruleset(Life(b=[3,6], s=[1,2,5]); init=init))

# Dimoeba
init1 = round.(Int8, max.(0.0, rand(70,70)))
sim!(output, Ruleset(Life(b=[3,5,6,7,8], s=[5,6,7,8]); init=init1))

## No death
sim!(output, Ruleset(Life(b=[3], s=[0,1,2,3,4,5,6,7,8]); init))

## 34 life
sim!(output, Ruleset(Life(b=[3,4], s=[3,4])); init=init, fps=10)

# Replicator
init2 = round.(Int8, max.(0.0, rand(70,70)))
init2[:, 1:30] .= 0
init2[21:50, :] .= 0
sim!(output, Ruleset(Life(b=[1,3,5,7], s=[1,3,5,7])); init=init2)</code></pre><h2><a class="nav-anchor" id="Rules-1" href="#Rules-1">Rules</a></h2><p>Rules define simulation behaviour. They hold data relevant to the simulation, and trigger dispatch of particular <a href="@ref"><code>applyrule</code></a> or <a href="@ref"><code>applyrule!</code></a> methods. Rules can be chained together arbitrarily to make composite simulations.</p><h3><a class="nav-anchor" id="Types-and-Constructors-1" href="#Types-and-Constructors-1">Types and Constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractRule" href="#CellularAutomataBase.AbstractRule"><code>CellularAutomataBase.AbstractRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractRule</code></pre><p>A rule contains all the information required to run a rule in a cellular simulation, given an initial array. Rules can be chained together sequentially.</p><p>The output of the rule for an AbstractRule is allways written to the current cell in the grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/types.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractCellRule" href="#CellularAutomataBase.AbstractCellRule"><code>CellularAutomataBase.AbstractCellRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractCellRule &lt;: AbstractRule</code></pre><p>A Rule that only writes and accesses a single cell: its return value is the new value of the cell. This limitation can be useful for performance optimisations.</p><p>Accessing the <code>data.source</code> and <code>data.dest</code> arrays directly is not guaranteed to have correct results, and should not be done.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/types.jl#L43-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractNeighborhoodRule" href="#CellularAutomataBase.AbstractNeighborhoodRule"><code>CellularAutomataBase.AbstractNeighborhoodRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractNeighborhoodRule &lt;: AbstractRule</code></pre><p>A Rule That only accesses a neighborhood, defined by its radius distance from the current cell.</p><p>For each cell a buffer will be populated containing the neighborhood cells, accessible with <code>buffer(data)</code>. This allows memory optimisations and the use of BLAS routines on the neighborhood.  It also means that and no bounds checking is required.</p><p><code>AbstractNeighborhoodRule</code> must read only from the state variable and the  neighborhood_buffer array, and never manually write to the <code>dest(data)</code> array.  Its return value is allways written to the central cell.</p><p>Custom Neighborhood rules must return their radius with a <code>radius()</code> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/types.jl#L20-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractPartialRule" href="#CellularAutomataBase.AbstractPartialRule"><code>CellularAutomataBase.AbstractPartialRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractPartialRule &lt;: AbstractRule</code></pre><p>AbstractPartialRule is for rules that manually write to whichever cells of the grid that they choose, instead of updating every cell with their output.</p><p>Updates to the destination array (<code>dest(data)</code>) must be performed manually, while the source array can be accessed with <code>source(data)</code>.</p><p>The dest array is copied from the source prior to running the <code>applyrule!</code> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/types.jl#L9-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractPartialNeighborhoodRule" href="#CellularAutomataBase.AbstractPartialNeighborhoodRule"><code>CellularAutomataBase.AbstractPartialNeighborhoodRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractPartialNeighborhoodRule &lt;: AbstractPartialRule</code></pre><p>A Rule that only writes to its neighborhood, defined by its radius distance from the current point. TODO: should this exist?</p><p>Custom PartialNeighborhood rules must return their radius with a <code>radius()</code> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/types.jl#L35-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.Life" href="#CellularAutomataBase.Life"><code>CellularAutomataBase.Life</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Rule for game-of-life style cellular automata. </p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th><th style="text-align: right">Limits</th></tr><tr><td style="text-align: right">neighborhood</td><td style="text-align: right">Any AbstractNeighborhood</td><td style="text-align: right">RadialNeighborhood{1}()</td><td style="text-align: right">nothing</td></tr><tr><td style="text-align: right">b</td><td style="text-align: right">Array, Tuple or Iterable of integers to match neighbors when cell is empty</td><td style="text-align: right">(3, 3)</td><td style="text-align: right">(0, 8)</td></tr><tr><td style="text-align: right">s</td><td style="text-align: right">Array, Tuple or Iterable of integers to match neighbors cell is full</td><td style="text-align: right">(2, 3)</td><td style="text-align: right">(0, 8)</td></tr></table></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0-L4">source</a></section><h2><a class="nav-anchor" id="Neighborhoods-1" href="#Neighborhoods-1">Neighborhoods</a></h2><p>Neighborhoods define a pattern of cells surrounding the current cell,  and how they are combined to update the value of the current cell.</p><h3><a class="nav-anchor" id="Types-and-Constructors-2" href="#Types-and-Constructors-2">Types and Constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractNeighborhood" href="#CellularAutomataBase.AbstractNeighborhood"><code>CellularAutomataBase.AbstractNeighborhood</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractNeighborhood</code></pre><p>Neighborhoods define how surrounding cells are related to the current cell. The <code>neighbors</code> function returns the sum of surrounding cells, as defined by the neighborhood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/neighborhoods.jl#L2-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.RadialNeighborhood" href="#CellularAutomataBase.RadialNeighborhood"><code>CellularAutomataBase.RadialNeighborhood</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct RadialNeighborhood{R} &lt;: AbstractNeighborhood{R}</code></pre><p>Radial neighborhoods calculate the surrounding neighborood from the radius around the central cell. The central cell is ommitted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/neighborhoods.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractCustomNeighborhood" href="#CellularAutomataBase.AbstractCustomNeighborhood"><code>CellularAutomataBase.AbstractCustomNeighborhood</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractCustomNeighborhood &lt;: AbstractNeighborhood{R}</code></pre><p>Custom neighborhoods are tuples of custom coordinates in relation to the central point of the current cell. They can be any arbitrary shape or size.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/neighborhoods.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.CustomNeighborhood" href="#CellularAutomataBase.CustomNeighborhood"><code>CellularAutomataBase.CustomNeighborhood</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Allows completely arbitrary neighborhood shapes by specifying each coordinate specifically.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.LayeredCustomNeighborhood" href="#CellularAutomataBase.LayeredCustomNeighborhood"><code>CellularAutomataBase.LayeredCustomNeighborhood</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Sets of custom neighborhoods that can have separate rules for each set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0-L2">source</a></section><h2><a class="nav-anchor" id="Output-1" href="#Output-1">Output</a></h2><h3><a class="nav-anchor" id="Output-Types-and-Constructors-1" href="#Output-Types-and-Constructors-1">Output Types and Constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractOutput" href="#CellularAutomataBase.AbstractOutput"><code>CellularAutomataBase.AbstractOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractOutput &lt;: AbstractArray{T,1}</code></pre><p>All outputs must inherit from AbstractOutput.</p><p>Simulation outputs are decoupled from simulation behaviour and in many cases can be used interchangeably.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/common.jl#L30-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.ArrayOutput" href="#CellularAutomataBase.ArrayOutput"><code>CellularAutomataBase.ArrayOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A simple output that stores each step of the simulation in a vector of arrays.</p><p><strong>Arguments:</strong></p><ul><li><code>frames</code>: Single init array or vector of arrays</li><li><code>tstop</code>: The length of the output.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/array.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.REPLOutput" href="#CellularAutomataBase.REPLOutput"><code>CellularAutomataBase.REPLOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An output that is displayed directly in the REPL. It can either store or discard simulation frames.</p><p><strong>Arguments:</strong></p><ul><li><code>frames</code>: Single init array or vector of arrays</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>fps::Real</code>: frames per second to run at</li><li><code>showfps::Real</code>: maximum displayed frames per second</li><li><code>store::Bool</code>: store frames or not</li><li><code>color</code>: a color from Crayons.jl</li><li><code>cutoff::Real</code>: the cutoff point to display a full or empty cell. Default is <code>0.5</code></li></ul><p>To choose the display type can pass <code>:braile</code> or <code>:block</code> to the constructor:</p><pre><code class="language-julia">REPLOutput{:block}(init)</code></pre><p>The default option is <code>:block</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/repl.jl#L12-L31">source</a></section><h3><a class="nav-anchor" id="Frame-processors-1" href="#Frame-processors-1">Frame processors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.AbstractFrameProcessor" href="#CellularAutomataBase.AbstractFrameProcessor"><code>CellularAutomataBase.AbstractFrameProcessor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractFrameProcessor</code></pre><p>Frame processors convert frame data into RGB24 images They can be passed as <code>procesor</code> keyword argument to outputs that have an image display.</p><p>To add new processor, define a type that inherits from AbstractFrameProcessor and a <a href="#CellularAutomataBase.frametoimage"><code>frametoimage</code></a> method:</p><pre><code class="language-julia">frametoimage(p::YourProcessor, output, frame, t) = some_rbg_image</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/frame_processing.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.GreyscaleProcessor" href="#CellularAutomataBase.GreyscaleProcessor"><code>CellularAutomataBase.GreyscaleProcessor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GreyscaleProcessor &lt;: AbstractFrameProcessor</code></pre><p>Converts output frames to a greyscale images</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/frame_processing.jl#L31-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.GreyscaleZerosProcessor" href="#CellularAutomataBase.GreyscaleZerosProcessor"><code>CellularAutomataBase.GreyscaleZerosProcessor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct GreyscaleZerosProcessor{C} &lt;: AbstractFrameProcessor</code></pre><p>&quot; Converts output frames to a greyscale image with the chosen color for zeros. Usefull for separating low values from actual zeros</p><p><strong>Arguments</strong></p><p><code>zerocolor</code>: RGB24 or a value that will be converted to RGB24 by the RGB24() constructor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/frame_processing.jl#L40-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.ColorSchemeProcessor" href="#CellularAutomataBase.ColorSchemeProcessor"><code>CellularAutomataBase.ColorSchemeProcessor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ColorSchemeProcessor{S} &lt;: AbstractFrameProcessor</code></pre><p>&quot; Converts output frames to a colorsheme.</p><p><strong>Arguments</strong></p><p><code>scheme</code>: a ColorSchemes.jl colorscheme.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/frame_processing.jl#L55-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.ColorSchemeZerosProcessor" href="#CellularAutomataBase.ColorSchemeZerosProcessor"><code>CellularAutomataBase.ColorSchemeZerosProcessor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ColorSchemeZerosProcessor{S, C} &lt;: AbstractFrameProcessor</code></pre><p>&quot; Converts frame to a colorshceme image with the chosen color for zeros. Usefull for separating low values from actual zeros</p><p><strong>Arguments</strong></p><p><code>scheme</code>: a ColorSchemes.jl colorscheme. <code>zerocolor</code>: RGB24 or a value that will be converted to RGB24 by the RGB24() constructor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/frame_processing.jl#L67-L75">source</a></section><h2><a class="nav-anchor" id="Overflow-1" href="#Overflow-1">Overflow</a></h2><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>AbstractOverflow</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.WrapOverflow" href="#CellularAutomataBase.WrapOverflow"><code>CellularAutomataBase.WrapOverflow</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct WrapOverflow &lt;: CellularAutomataBase.AbstractOverflow</code></pre><p>Wrap cords that overflow boundaries back to the opposite side</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/types.jl#L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.RemoveOverflow" href="#CellularAutomataBase.RemoveOverflow"><code>CellularAutomataBase.RemoveOverflow</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct RemoveOverflow &lt;: CellularAutomataBase.AbstractOverflow</code></pre><p>Remove coords that overflow boundaries</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/types.jl#L63">source</a></section><h1><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.distances-Tuple{Any}" href="#CellularAutomataBase.distances-Tuple{Any}"><code>CellularAutomataBase.distances</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">distances(a::AbstactMatrix)</code></pre><p>Calculate the matrix of distances (in units of cells) between all cells in a matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/utils.jl#L30-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.replay-Tuple{AbstractOutput}" href="#CellularAutomataBase.replay-Tuple{AbstractOutput}"><code>CellularAutomataBase.replay</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">replay(output::AbstractOutput)</code></pre><p>Show a stored simulation again. You can also use this to show a simulation in different output type.</p><p>If you ran a simulation with <code>store=false</code> there won&#39;t be much to replay.</p><p><strong>Example</strong></p><pre><code class="language-julia">replay(REPLOutput(output))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/framework.jl#L67-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.resume!-Tuple{Any,Any}" href="#CellularAutomataBase.resume!-Tuple{Any,Any}"><code>CellularAutomataBase.resume!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">resume!(output, ruleset; tstop=100)</code></pre><p>Restart the simulation where you stopped last time.</p><p><strong>Arguments</strong></p><p>See <a href="#CellularAutomataBase.sim!-Tuple{Any,Any}"><code>sim!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/framework.jl#L44-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.ruletypes-Tuple{Ruleset}" href="#CellularAutomataBase.ruletypes-Tuple{Ruleset}"><code>CellularAutomataBase.ruletypes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return a tuple of the base types of the rules in the ruleset</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/utils.jl#L55-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.savegif-Tuple{String,AbstractOutput}" href="#CellularAutomataBase.savegif-Tuple{String,AbstractOutput}"><code>CellularAutomataBase.savegif</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">savegif(filename::String, output::AbstractOutput)</code></pre><p>Write the output array to a gif. Saving very large gifs may trigger a bug in imagemagick.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/frame_processing.jl#L83-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.sim!-Tuple{Any,Any}" href="#CellularAutomataBase.sim!-Tuple{Any,Any}"><code>CellularAutomataBase.sim!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sim!(output, ruleset, init; tstop=1000)</code></pre><p>Runs the whole simulation, passing the destination aray to the passed in output for each time-step.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: An <a href="@ref">AbstractOutput</a> to store frames or display them on the screen.</li><li><code>ruleset</code>: A Rule() containing one ore more <a href="#CellularAutomataBase.AbstractRule"><code>AbstractRule</code></a>. These will each be run in sequence.</li><li><code>init</code>: The initialisation array.</li><li><code>args</code>: additional args are passed through to <a href="@ref"><code>rule</code></a> and <a href="#CellularAutomataBase.neighbors"><code>neighbors</code></a> methods.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tstop</code>: Any Number. Default: 100</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/framework.jl#L1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.addpadding-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Any}} where N where T" href="#CellularAutomataBase.addpadding-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Any}} where N where T"><code>CellularAutomataBase.addpadding</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Find the maximum radius required by all rules Add padding around the original init array, offset into the negative So that the first real cell is still 1, 1</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/simulationdata.jl#L101-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.applyrule" href="#CellularAutomataBase.applyrule"><code>CellularAutomataBase.applyrule</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">applyrule(rule::AbstractRule, data, state, index)</code></pre><p>Updates cell values based on their current state and the state of other cells as defined in the Rule.</p><p><strong>Arguments:</strong></p><ul><li><code>rule</code> : <a href="#CellularAutomataBase.AbstractRule"><code>AbstractRule</code></a></li><li><code>data</code> : <a href="@ref"><code>FrameData</code></a></li><li><code>state</code>: the value of the current cell</li><li><code>index</code>: a (row, column) tuple of Int for the current cell coordinates - <code>t</code>: the current time step</li><li><code>args</code>: additional arguments passed through from user input to <a href="#CellularAutomataBase.sim!-Tuple{Any,Any}"><code>sim!</code></a></li></ul><p>Returns a value to be written to the current cell.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/interface.jl#L1-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.applyrule!" href="#CellularAutomataBase.applyrule!"><code>CellularAutomataBase.applyrule!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">applyrule!(rule::AbstractPartialRule, data, state, index)</code></pre><p>A rule that manually writes to the dest array, used in rules inheriting from <a href="#CellularAutomataBase.AbstractPartialRule"><code>AbstractPartialRule</code></a>.</p><p><strong>Arguments:</strong></p><p>see <a href="#CellularAutomataBase.applyrule"><code>applyrule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/interface.jl#L19-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.applyrule-Tuple{Life,Any,Any,Any,Any}" href="#CellularAutomataBase.applyrule-Tuple{Life,Any,Any,Any,Any}"><code>CellularAutomataBase.applyrule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rule(model::AbstractLife, state)</code></pre><p>Rule for game-of-life style cellular automata. This is a demonstration of  Cellular Automata more than a seriously optimised game of life model.</p><p>Cells becomes active if it is empty and the number of neightbors is a number in the b array, and remains active the cell is active and the number of neightbors is in the s array.</p><p>Returns: boolean</p><p><strong>Examples (gleaned from CellularAutomata.jl)</strong></p><p>Use the arrow keys to scroll around, or zoom out if your terminal can do that!</p><pre><code class="language-julia"># Life. 
init = round.(Int64, max.(0.0, rand(-3.0:0.1:1.0, 300,300)))
output = REPLOutput{:block}(init; fps=10, color=:red)
sim!(output, model, init; time=1000)

# Dimoeba
init = rand(0:1, 400, 300)
init[:, 100:200] .= 0
output = REPLOutput{:braile}(init; fps=25, color=:blue)
sim!(output, Ruleset(Life(b=(3,5,6,7,8), s=(5,6,7,8))), init; time=1000)

# Replicator
init = fill(1, 300,300)
init[:, 100:200] .= 0
init[10, :] .= 0
output = REPLOutput{:block}(init; fps=60, color=:yellow)
sim!(output, Ruleset(Life(b=(1,3,5,7), s=(1,3,5,7))), init; time=1000)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/life.jl#L14-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.applyrule-Tuple{Tuple,Any,Any,Any,Any}" href="#CellularAutomataBase.applyrule-Tuple{Tuple,Any,Any,Any,Any}"><code>CellularAutomataBase.applyrule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">applyrule(rules::Tuple, data, state, (i, j))</code></pre><p>Subrules. If a tuple of rules is passed to applyrule, run them sequentially for each cell. This can have much beter performance as no writes occur between rules, and they are essentially compiled together into compound rules. This gives correct results only for AbstractCellRule, or for a single AbstractNeighborhoodRule followed by AbstractCellRule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/maprules.jl#L294-L301">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.frametoimage" href="#CellularAutomataBase.frametoimage"><code>CellularAutomataBase.frametoimage</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert frame matrix to RGB24, using any AbstractFrameProcessor</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/frame_processing.jl#L19-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.handleoverflow!-Tuple{CellularAutomataBase.AbstractSimData,Integer}" href="#CellularAutomataBase.handleoverflow!-Tuple{CellularAutomataBase.AbstractSimData,Integer}"><code>CellularAutomataBase.handleoverflow!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Wrap overflow where required. This optimisation allows us to ignore bounds checks on neighborhoods and still use a wraparound grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/maprules.jl#L218-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.hoodsize-Tuple{Integer}" href="#CellularAutomataBase.hoodsize-Tuple{Integer}"><code>CellularAutomataBase.hoodsize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sizefromradius(radius)</code></pre><p>Get the size of a neighborhood dimension from its radius,  which is always 2r + 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/utils.jl#L47-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.inbounds-Tuple{Tuple,Tuple,Any}" href="#CellularAutomataBase.inbounds-Tuple{Tuple,Tuple,Any}"><code>CellularAutomataBase.inbounds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inbounds(x, max, overflow)</code></pre><p>Check grid boundaries for a single coordinate and max value or a tuple of coorinates and max values.</p><p>Returns a tuple containing the coordinate(s) followed by a boolean <code>true</code> if the cell is in bounds, <code>false</code> if not.</p><p>Overflow of type <a href="#CellularAutomataBase.RemoveOverflow"><code>RemoveOverflow</code></a> returns the coordinate and <code>false</code> to skip coordinates that overflow outside of the grid. <a href="#CellularAutomataBase.WrapOverflow"><code>WrapOverflow</code></a> returns a tuple with the current position or it&#39;s wrapped equivalent, and <code>true</code> as it is allways in-bounds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/utils.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.initframes!-Tuple{AbstractGraphicOutput,Any}" href="#CellularAutomataBase.initframes!-Tuple{AbstractGraphicOutput,Any}"><code>CellularAutomataBase.initframes!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Frames are deleted and reallocated during the simulation, as performance is often display limited, and this allows runs of any length.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/common.jl#L132-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.initframes!-Tuple{AbstractOutput,Any}" href="#CellularAutomataBase.initframes!-Tuple{AbstractOutput,Any}"><code>CellularAutomataBase.initframes!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Frames are preallocated and reused.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/common.jl#L140-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.initstatus!-Tuple{Any,Any,Any}" href="#CellularAutomataBase.initstatus!-Tuple{Any,Any,Any}"><code>CellularAutomataBase.initstatus!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Initialise the block status array. This tracks whether anything has to be done in an area of the main array.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/simulationdata.jl#L132-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.maprule!-Tuple{CellularAutomataBase.AbstractSimData,AbstractRule}" href="#CellularAutomataBase.maprule!-Tuple{CellularAutomataBase.AbstractSimData,AbstractRule}"><code>CellularAutomataBase.maprule!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Apply the rule for each cell in the grid, using optimisations allowed for the supertype of the rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/maprules.jl#L33-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.maxradius-Tuple{Ruleset}" href="#CellularAutomataBase.maxradius-Tuple{Ruleset}"><code>CellularAutomataBase.maxradius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Find the largest radius present in the passed in rules.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/maprules.jl#L278-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.neighbors" href="#CellularAutomataBase.neighbors"><code>CellularAutomataBase.neighbors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">neighbors(hood::AbstractNeighborhood, state, indices, t, source, args...)</code></pre><p>Checks all cells in neighborhood and combines them according to the particular neighborhood type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/interface.jl#L30-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.neighbors-Tuple{AbstractCustomNeighborhood,Any,Any,Any}" href="#CellularAutomataBase.neighbors-Tuple{AbstractCustomNeighborhood,Any,Any,Any}"><code>CellularAutomataBase.neighbors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">neighbors(hood::AbstractCustomNeighborhood, buf, state)</code></pre><p>Sum a single custom neighborhood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/neighborhoods.jl#L58-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.neighbors-Tuple{LayeredCustomNeighborhood,Any,Any,Any}" href="#CellularAutomataBase.neighbors-Tuple{LayeredCustomNeighborhood,Any,Any,Any}"><code>CellularAutomataBase.neighbors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>neighbors(hood::LayeredCustomNeighborhood, buf, state) Sum multiple custom neighborhoods separately.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/neighborhoods.jl#L76-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.neighbors-Tuple{RadialNeighborhood,Any,Any,Any}" href="#CellularAutomataBase.neighbors-Tuple{RadialNeighborhood,Any,Any,Any}"><code>CellularAutomataBase.neighbors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">neighbors(hood::RadialNeighborhood, buf, state)</code></pre><p>Sums moore nieghborhoods of any dimension. </p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/neighborhoods.jl#L51-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.radius" href="#CellularAutomataBase.radius"><code>CellularAutomataBase.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Return the radius of a rule if it has one, otherwise zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/interface.jl#L39-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.runsim!-Tuple{Any,Vararg{Any,N} where N}" href="#CellularAutomataBase.runsim!-Tuple{Any,Vararg{Any,N} where N}"><code>CellularAutomataBase.runsim!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>run the simulation either directly or asynchronously.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/framework.jl#L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.sequencerules!-Tuple{Any,Ruleset}" href="#CellularAutomataBase.sequencerules!-Tuple{Any,Ruleset}"><code>CellularAutomataBase.sequencerules!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Iterate over all rules recursively, swapping source and dest arrays. Returns a tuple containing the source and dest arrays for the next iteration.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/framework.jl#L133-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.showframe-Tuple{AbstractGraphicOutput}" href="#CellularAutomataBase.showframe-Tuple{AbstractGraphicOutput}"><code>CellularAutomataBase.showframe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">showframe(output::AbstractOutput, [t])</code></pre><p>Show the last frame of the output, or the frame at time t.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/outputs/common.jl#L150-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.simdata-Tuple{AbstractRuleset,AbstractArray}" href="#CellularAutomataBase.simdata-Tuple{AbstractRuleset,AbstractArray}"><code>CellularAutomataBase.simdata</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Generate simulation data to match a ruleset and init array.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/simulationdata.jl#L73-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.simloop!-NTuple{4,Any}" href="#CellularAutomataBase.simloop!-NTuple{4,Any}"><code>CellularAutomataBase.simloop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Loop over the selected timespan, running the ruleset and displaying the output</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/framework.jl#L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.swapsource-Tuple{Any}" href="#CellularAutomataBase.swapsource-Tuple{Any}"><code>CellularAutomataBase.swapsource</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Swap source and dest arrays. Allways returns regular SimData.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/simulationdata.jl#L54-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CellularAutomataBase.updatetime-Tuple{CellularAutomataBase.SimData,Any}" href="#CellularAutomataBase.updatetime-Tuple{CellularAutomataBase.SimData,Any}"><code>CellularAutomataBase.updatetime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Uptate timestamp</p></div></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/CellularAutomataBase.jl/blob/9390d1edfd9d09769a48279bf2652a60ef5ecf3a/src/simulationdata.jl#L65-L67">source</a></section><footer><hr/></footer></article></body></html>
