<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicGrids.jl · DynamicGrids.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DynamicGrids.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DynamicGrids.jl</a><ul class="internal"><li><a class="tocitem" href="#More-Examples-1"><span>More Examples</span></a></li><li><a class="tocitem" href="#Rules-1"><span>Rules</span></a></li><li><a class="tocitem" href="#Neighborhoods-1"><span>Neighborhoods</span></a></li><li><a class="tocitem" href="#Output-1"><span>Output</span></a></li><li><a class="tocitem" href="#Overflow-1"><span>Overflow</span></a></li><li><a class="tocitem" href="#Internal-data-handling-1"><span>Internal data handling</span></a></li><li class="toplevel"><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DynamicGrids.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DynamicGrids.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicGrids.jl-1"><a class="docs-heading-anchor" href="#DynamicGrids.jl-1">DynamicGrids.jl</a><a class="docs-heading-anchor-permalink" href="#DynamicGrids.jl-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids" href="#DynamicGrids"><code>DynamicGrids</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>DynamicGrids</strong></p><p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://cesaraustralia.github.io/DynamicGrids.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://travis-ci.org/cesaraustralia/DynamicGrids.jl"><img src="https://travis-ci.org/cesaraustralia/DynamicGrids.jl.svg?branch=master" alt="Build Status"/></a>  <a href="http://codecov.io/github/cesaraustralia/DynamicGrids.jl?branch=master"><img src="http://codecov.io/github/cesaraustralia/DynamicGrids.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>DynamicGrids is a generalised framework for building high-performance grid-based spatial models, including celluar automata, but also allowing arbitrary behviours such as long distance jumps and interactions between multiple grids. It is extended by <a href="https://github.com/cesaraustralia/Dispersal.jl">Dispersal.jl</a> for modelling organism dispersal processes.</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/dispersal_quarantine.gif" alt="Dispersal quarantine"/></p><p><em>A dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the  GtkOuput from <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk</a>.  Note that this is indicative of the real-time frame-rate on a laptop.</em></p><p>A DynamicGrids.jl simulation is run with a script like this one running the included game of life model <code>Life()</code>:</p><pre><code class="language-">using DynamicGrids, Crayons

init = rand(Bool, 150, 200)
output = REPLOutput(init; fps=30, color=Crayon(foreground=:red, background=:black, bold=true))
ruleset = Ruleset(Life(); init=init)
sim!(output, ruleset; tspan=(1, 200))</code></pre><p><img src="https://github.com/cesaraustralia/DynamicGrids.jl/blob/media/life.gif?raw=true" alt="REPL life"/></p><p><em>A game of life simulation being displayed directly in a terminal.</em></p><p><strong>Concepts</strong></p><p>The framework is highly customisable, but there are some central ideas that define how a simulation works: <em>rules</em> and <em>interactions</em>, <em>init</em> arrays and <em>outputs</em>.</p><p><strong>Rules</strong></p><p>Rules hold the parameters for running a simulation. Each rule triggers a specific <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> method that operates on each of the active cells in the grid. Rules come in a number of flavours (outlined in the  <a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Rules-1">docs</a>), which allow assumptions to be made about running them that can greatly improve performance. Rules are joined in a <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> object and run in sequence:</p><pre><code class="language-none">ruleset = Ruleset(Life(2, 3))</code></pre><p>The <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> wrapper seems a little redundant here, but multiple models can be combined in a <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a>. Each rule will be run for the whole grid, in sequence, using appropriate optimisations depending on the parent types of each rule:</p><pre><code class="language-">ruleset = Ruleset(rule1, rule2)</code></pre><p>For better performance (often ~2x), models included in a <a href="#DynamicGrids.Chain"><code>Chain</code></a> object will be combined into a single model, using only one array read and write. This optimisation is limited to <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>, or a <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> followed by <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>. If the <code>@inline</code> compiler macro is used on all <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> methods, all rules in a <a href="#DynamicGrids.Chain"><code>Chain</code></a> will be compiled together into a single,  efficient function call.</p><pre><code class="language-">ruleset = Ruleset(rule1, Chain(rule2, rule3, rule4))</code></pre><p>A <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> can also hold rules that act on multiple grids. These may either run side by side independently (say for live comparative analysis), or interact.</p><p><strong>Init</strong></p><p>The init array may be any AbstractArray or a NamedTuple of AbstractArray,  It contains whatever initialisation data is required to start the simulation.  The array type, size and element type of the init array determine the types used in the simulation, as well as providing the initial conditions:</p><pre><code class="language-juli">init = rand(Float32, 100, 100)</code></pre><p>An init array can be attached to a <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a>: </p><pre><code class="language-none">ruleset = Ruleset(Life(); init=init)</code></pre><p>or passed into a simulation, where it will take preference over the <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> init:</p><pre><code class="language-none">sim!(output, rulset; init=init)</code></pre><p>For multiple grids, init is a NamedTuple of equal-sized arrays matching the names given to each <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> :</p><pre><code class="language-">init = (predator=rand(100, 100), prey=(rand(100, 100))</code></pre><p>Handling and passing of the correct arrays is automated by DynamicGrids.jl. <a href="#DynamicGrids.Rule"><code>Rule</code></a>s must specify which grids they require in what order, using the first two (<code>R</code> and <code>W</code>) type parameters. </p><p>Dimensional or spatial init arrays from <a href="https://github.com/rafaqz/DimensionalData.jl">DimensionalData.jl</a> of <a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a> will propagate through the model to return output with explicit dimensions. This will plot correctly as a map using <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>, to which shape files and observation points can be easily added.</p><p><strong>Output</strong></p><p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Output-1">Outputs</a> are ways of storing or viewing a simulation. They can be used interchangeably depending on your needs: <a href="#DynamicGrids.ArrayOutput"><code>ArrayOutput</code></a> is a simple storage structure for high performance-simulations. As with most outputs, it is initialised with the init array, but in this case it also requires the number of simulation frames to preallocate before the simulation runs.</p><pre><code class="language-">output = ArrayOutput(init, 10)</code></pre><p>The <a href="#DynamicGrids.REPLOutput"><code>REPLOutput</code></a> shown above is an inbuilt <a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a> that can be useful for checking a simulation when working in a terminal or over ssh:</p><pre><code class="language-">output = REPLOutput(init)</code></pre><p><a href="#DynamicGrids.ImageOutput"><code>ImageOutput</code></a> is the most complex class of outputs, allowing full color visual simulations using COlorSchemes.jl. It can also display interactions using color  composites or layouts, as shown above in the quarantine simulation.</p><p><a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a> provides simulation interfaces for use in Juno, Jupyter, web pages or electron apps, with live interactive control over parameters. <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> is a simple graphical output for Gtk. These packages are kept separate to avoid dependencies when being used in non-graphical simulations. </p><p>Outputs are also easy to write, and high performance or applications may benefit from writing a custom output to reduce memory use, such as running a loss function on the fly instead of storing the array. Performance of DynamicGrids.jl is dominated by cache interactions, and reducing memory use has significant positive effects. Custom  <a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Frame-processors-1">frame processors</a> can also be written, which can help developing specialised visualisations.</p><p><strong>Example</strong></p><p>This example implements a very simple forest fire model:</p><pre><code class="language-">using DynamicGrids, DynamicGridsGtk, ColorSchemes, Colors

const DEAD = 1
const ALIVE = 2
const BURNING = 3

# Define the Rule struct
struct ForestFire{R,W,N,PC,PR} &lt;: NeighborhoodRule{R,W}
    neighborhood::N
    prob_combustion::PC
    prob_regrowth::PR
end
ForestFire(; grid=:_default_, neighborhood=RadialNeighborhood{1}(), prob_combustion=0.0001, prob_regrowth=0.01) =
    ForestFire{grid,grid}(neighborhood, prob_combustion, prob_regrowth)

# Define an [`applyrule`](@ref) method to be broadcasted over the grid for the [`ForestFire`](@ref) rule
@inline DynamicGrids.applyrule(rule::ForestFire, data, state::Integer, index, hoodbuffer) =
    if state == ALIVE
        if BURNING in DynamicGrids.neighbors(rule, hoodbuffer)
            BURNING
        else
            rand() &lt;= rule.prob_combustion ? BURNING : ALIVE
        end
    elseif state in BURNING
        DEAD
    else
        rand() &lt;= rule.prob_regrowth ? ALIVE : DEAD
    end

# Set up the init array, ruleset and output (using a Gtk window)
init = fill(ALIVE, 400, 400)
ruleset = Ruleset(ForestFire(); init=init)
processor = ColorProcessor(scheme=ColorSchemes.rainbow, zerocolor=RGB24(0.0))
output = GtkOutput(init; fps=25, minval=DEAD, maxval=BURNING, processor=processor)

# Run the simulation
sim!(output, ruleset; tspan=(1, 200))

# Save the output as a gif
savegif(&quot;forestfire.gif&quot;, output)</code></pre><p><img src="https://user-images.githubusercontent.com/2534009/72052469-5450c580-3319-11ea-8948-5196d1c6fd33.gif" alt="forestfire"/></p><p>We could also use a &quot;windy&quot; custom neighborhood:</p><pre><code class="language-">windyhood = CustomNeighborhood((1,1), (1,2), (1,3), (2,1), (3,1))
ruleset = Ruleset(ForestFire(; neighborhood=windyhood); init=init)
sim!(output, ruleset; tspan=(1, 200))
savegif(&quot;windy_forestfire.gif&quot;, output)</code></pre><p><img src="https://user-images.githubusercontent.com/2534009/72198637-a95d1a80-3484-11ea-8b77-25a4a94b3943.gif" alt="windy_forestfire"/></p><p>Timing the simulation for 200 steps, the performance is quite good:</p><pre><code class="language-">output = ArrayOutput(init, 200)
@time sim!(output, ruleset; tspan=(1, 200))
 1.384755 seconds (640 allocations: 2.569 MiB)

# To save a gif of the ArrayOutput we need to pass in a processor and the min and max
# values used in the simulation:

savegif(&quot;forestfire.gif&quot;, output; minval=DEAD, maxval=BURNING, processor=processor)</code></pre><p><strong>Alternatives</strong></p><p><a href="https://github.com/JuliaDynamics/Agents.jl">Agents.jl</a> can also do cellular-automata style simulations. The design of Agents.jl is to iterate over a list of agents, instead of broadcasting over an array of cells. This approach is well suited to when you need to track the movement and details about individual agents throughout the simulation. </p><p>However, for simple grid models where you don&#39;t need to track individuals, like the forest fire model above, DynamicGrids.jl is two orders of magnitude faster than Agents.jl, and provides better visualisation tools. If you are doing grid-based simulation and you don&#39;t need to track individual agents, DynamicGrids.jl is probably the best tool. For other use cases, try Agents.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/DynamicGrids.jl#L3-L243">source</a></section></article><h2 id="More-Examples-1"><a class="docs-heading-anchor" href="#More-Examples-1">More Examples</a><a class="docs-heading-anchor-permalink" href="#More-Examples-1" title="Permalink"></a></h2><p>While this package isn&#39;t designed or optimised specifically to run the game of life, it&#39;s a simple demonstration of what it can do. This example runs a game of life and displays it in a REPLOutput.</p><pre><code class="language-julia">using DynamicGrids

# Build a random starting grid
init = round.(Int8, max.(0.0, rand(-2.0:0.1:1.0, 70,70)))

# Use the default game of life model
model = Ruleset(Life())

# Use an output that shows the cellular automata as blocks in the REPL
output = REPLOutput(init; fps=5)

sim!(output, model; init=init, tspan=(1, 50))</code></pre><pre><code class="language-none">1-element REPLOutput{Array{Int8,2},Array{Array{Int8,2},1},Int64,Float64,Float64,Int64,Symbol,Float64,Block}:
 [0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 1 0 … 0 0]</code></pre><p>More life-like examples:</p><pre><code class="language-julia"># Morley
sim!(output, Ruleset(Life(b=[3,6,8], s=[2,4,5]); init=init))

# 2x2
sim!(output, Ruleset(Life(b=[3,6], s=[1,2,5]); init=init))

# Dimoeba
init1 = round.(Int8, max.(0.0, rand(70,70)))
sim!(output, Ruleset(Life(b=[3,5,6,7,8], s=[5,6,7,8]); init=init1))

## No death
sim!(output, Ruleset(Life(b=[3], s=[0,1,2,3,4,5,6,7,8]); init))

## 34 life
sim!(output, Ruleset(Life(b=[3,4], s=[3,4])); init=init, fps=10)

# Replicator
init2 = round.(Int8, max.(0.0, rand(70,70)))
init2[:, 1:30] .= 0
init2[21:50, :] .= 0
sim!(output, Ruleset(Life(b=[1,3,5,7], s=[1,3,5,7])); init=init2)</code></pre><h2 id="Rules-1"><a class="docs-heading-anchor" href="#Rules-1">Rules</a><a class="docs-heading-anchor-permalink" href="#Rules-1" title="Permalink"></a></h2><p>Rules define simulation behaviour. They hold data relevant to the simulation, and trigger dispatch of particular <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> or <a href="#DynamicGrids.applyrule!"><code>applyrule!</code></a> methods. Rules can be chained together arbitrarily to make composite simulations across any number of grids.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Ruleset" href="#DynamicGrids.Ruleset"><code>DynamicGrids.Ruleset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ruleset(rules...; init=nothing, mask=nothing, overflow=RemoveOverflow(), opt=SparseeOpt(), cellsize=1, timestep=1)</code></pre><p>A container for holding a sequence of <code>Rule</code>, an <code>init</code> array and other simulaiton details. Rules will be run in the order they are passed, ie. <code>Ruleset(rule1, rule2, rule3)</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>init</code>: init grid(s) to use if none are supplied to <code>sim!</code>. An <code>AbstractArray</code>, a <code>NamedTuple</code> of <code>AbsractactArray</code>, or <code>nothing</code>.</li><li><code>mask</code>: An array of Bool matching the size of <code>init</code>. Cells that are <code>false</code> will not run.</li><li><code>overflow</code>: determine what to do with overflow of grid edges. Options are <code>RemoveOverflow()</code> or <code>WrapOverflow()</code>. Available from <code>applyrule</code> with <code>overflow(data)</code></li><li><code>cellsize</code>: Size of cells. Available from <code>applyrule</code> with <code>timestep(data)</code></li><li><code>timestep</code>: timestep size for all rules. eg. <code>Month(1)</code> or <code>1u&quot;s&quot;</code>. Available from <code>applyrule</code> with <code>timestep(data)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Rule" href="#DynamicGrids.Rule"><code>DynamicGrids.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Rule</code></pre><p>A rule contains all the information required to run a rule in a simulation, given an initial array. Rules can be chained together sequentially.</p><p>By default the output of the rule for a Rule is automatically written to the current cell in the grid.</p><p>Rules are applied to the grid using the <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/rules.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CellRule" href="#DynamicGrids.CellRule"><code>DynamicGrids.CellRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type CellRule &lt;: Rule{R,W}</code></pre><p>A Rule that only writes and accesses a single cell: its return value is the new value of the cell(s). This limitation can be useful for performance optimisation, such as wrapping rules in <a href="#DynamicGrids.Chain"><code>Chain</code></a> so that no writes occur between rules.</p><p>Accessing <code>source(data)</code> and <code>dest(data)</code> arrays directly from CellRule is not guaranteed to have correct results, and should not be done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/rules.jl#L58-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.NeighborhoodRule" href="#DynamicGrids.NeighborhoodRule"><code>DynamicGrids.NeighborhoodRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type NeighborhoodRule &lt;: Rule{R,W}</code></pre><p>A Rule that only accesses a neighborhood centered around the current cell. NeighborhoodRule is applied with the method:</p><pre><code class="language-julia">applyrule(rule::Life, data, state, index, buffer)</code></pre><p>For each cell a neighborhood buffer will be populated containing the neighborhood cells, and passed to <code>applyrule</code> as the extra <code>buffer</code> argmuent.</p><p>This allows memory optimisations and the use of BLAS routines on the neighborhood buffer for <a href="#DynamicGrids.RadialNeighborhood"><code>RadialNeighborhood</code></a>. It also means that and no bounds checking is required in neighborhood code, a major performance gain.</p><p><code>neighbors(buffer)</code> returns an iterator over the buffer that is generic to any neigborhood type - Custom shapes as well as square radial neighborhoods.</p><p><code>NeighborhoodRule</code> should read only from the state args and the neighborhood buffer array. The return value is written to the central cell for the next grid frame.</p><p>For neighborhood rules with multiple read grids, the first is the one given a neighborhood buffer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/rules.jl#L77-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.PartialRule" href="#DynamicGrids.PartialRule"><code>DynamicGrids.PartialRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type PartialRule &lt;: Rule{R,W}</code></pre><p>PartialRule is for rules that manually write to whichever cells of the grid that they choose, instead of automatically updating every cell with their output.</p><p>Updates to the destination grids data must be performed manually by <code>data[:key] = x</code>. Updating block status is handled automatically on write.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/rules.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.PartialNeighborhoodRule" href="#DynamicGrids.PartialNeighborhoodRule"><code>DynamicGrids.PartialNeighborhoodRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type PartialNeighborhoodRule &lt;: PartialRule{R,W}</code></pre><p>A Rule that only writes to its neighborhood, defined by its radius distance from the current point.</p><p>PartialNeighborhood rules must return their radius with a <code>radius()</code> method, although by default this will be called on the result of <code>neighborhood(rule)</code>.</p><p>TODO: performance optimisations with a neighborhood buffer, simular to <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> but for writing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/rules.jl#L110-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Map" href="#DynamicGrids.Map"><code>DynamicGrids.Map</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Map{R,W}(f)
Map(f; read, write)</code></pre><p>A <a href="#DynamicGrids.CellRule"><code>CellRule</code></a> that applies a function <code>f</code> to the <code>read</code> grid cells and returns the <code>write</code> cells.</p><p>Especially convenient with <code>do</code> notation.</p><p><strong>Example</strong></p><p>Set the cells of grid <code>:c</code> to the sum of <code>:a</code> and <code>:b</code>.</p><pre><code class="language-julia">rule = Map{Tuple{:a,:b},:c}() do a, b
    a + b 
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Chain" href="#DynamicGrids.Chain"><code>DynamicGrids.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Chain{R, W, T&lt;:Union{Tuple{}, Tuple{Union{#s29, #s28} where #s28&lt;:CellRule where #s29&lt;:NeighborhoodRule,Vararg{CellRule,N} where N}}} &lt;: Rule{R,W}</code></pre><p><code>Chain</code>s allow chaining rules together to be completed in a single processing step without intermediate reads or writes from grids. They are potentially compiled together into a single function call, especially if you use <code>@inline</code> on all <code>applyrule</code>. methods. <code>Chain</code> can hold either all <a href="#DynamicGrids.CellRule"><code>CellRule</code></a> or <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> followed by <a href="@ref">CellRule`</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/chain.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Life" href="#DynamicGrids.Life"><code>DynamicGrids.Life</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rule for game-of-life style cellular automata. This is a demonstration of  Cellular Automata more than a seriously optimised game of life rule.</p><p>Cells becomes active if it is empty and the number of neightbors is a number in the b array, and remains active the cell is active and the number of neightbors is in the s array.</p><p>Returns: boolean</p><p><strong>Examples (gleaned from CellularAutomata.jl)</strong></p><pre><code class="language-julia"># Life. 
init = round.(Int64, max.(0.0, rand(-3.0:0.1:1.0, 300,300)))
output = REPLOutput(init; fps=10, color=:red)
sim!(output, rule, init; tspan=(1, 1000)

# Dimoeba
init = rand(0:1, 400, 300)
init[:, 100:200] .= 0
output = REPLOutput{:braile}(init; fps=25, color=:blue)
sim!(output, Ruleset(Life(b=(3,5,6,7,8), s=(5,6,7,8))), init; tspan=(1, 1000))

# Replicator
init = fill(1, 300,300)
init[:, 100:200] .= 0
init[10, :] .= 0
output = REPLOutput(init; fps=60, color=:yellow)
sim!(output, Ruleset(Life(b=(1,3,5,7), s=(1,3,5,7))), init; tspan=(1, 1000))</code></pre><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th><th style="text-align: right">Limits</th></tr><tr><td style="text-align: right">neighborhood</td><td style="text-align: right">Any Neighborhood</td><td style="text-align: right">nothing</td><td style="text-align: right">nothing</td></tr><tr><td style="text-align: right">b</td><td style="text-align: right">Array, Tuple or Iterable of integers to match neighbors when cell is empty</td><td style="text-align: right">nothing</td><td style="text-align: right">(0, 8)</td></tr><tr><td style="text-align: right">s</td><td style="text-align: right">Array, Tuple or Iterable of integers to match neighbors cell is full</td><td style="text-align: right">nothing</td><td style="text-align: right">(0, 8)</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule" href="#DynamicGrids.applyrule"><code>DynamicGrids.applyrule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyrule(rule::Rule, data, state, index, [buffer])</code></pre><p>Updates cell values based on their current state and the  state of other cells as defined in the Rule.</p><p><strong>Arguments:</strong></p><ul><li><code>rule</code> : <a href="#DynamicGrids.Rule"><code>Rule</code></a></li><li><code>data</code> : <a href="#DynamicGrids.SimData"><code>SimData</code></a></li><li><code>state</code>: the value(s) of the current cell</li><li><code>index</code>: a (row, column) tuple of Int for the current cell coordinates - <code>t</code>: the current time step</li><li><code>buffer</code>: a neighborhood burrer array passed to [<code>NeighborhoodRule</code>].</li></ul><p>Returns the values) to be written to the current cell(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/interface.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule!" href="#DynamicGrids.applyrule!"><code>DynamicGrids.applyrule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyrule!(rule::PartialRule, data, state, index)</code></pre><p>A rule that manually writes to the grid data array,  used in all rules inheriting from <a href="#DynamicGrids.PartialRule"><code>PartialRule</code></a>.</p><p><strong>Arguments:</strong></p><p>see <a href="#DynamicGrids.applyrule"><code>applyrule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/interface.jl#L19-L27">source</a></section></article><h2 id="Neighborhoods-1"><a class="docs-heading-anchor" href="#Neighborhoods-1">Neighborhoods</a><a class="docs-heading-anchor-permalink" href="#Neighborhoods-1" title="Permalink"></a></h2><p>Neighborhoods define a pattern of cells surrounding the current cell,  and how they are combined to update the value of the current cell.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhood" href="#DynamicGrids.Neighborhood"><code>DynamicGrids.Neighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Neighborhood</code></pre><p>Neighborhoods define how surrounding cells are related to the current cell. The <code>neighbors</code> function returns the sum of surrounding cells, as defined by the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/neighborhoods.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractRadialNeighborhood" href="#DynamicGrids.AbstractRadialNeighborhood"><code>DynamicGrids.AbstractRadialNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractRadialNeighborhood &lt;: Neighborhood{R}</code></pre><p>A Moore-style neighborhood where a square are with a center radius <code>(D - 1) / 2</code> where D is the diameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/neighborhoods.jl#L13-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RadialNeighborhood" href="#DynamicGrids.RadialNeighborhood"><code>DynamicGrids.RadialNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RadialNeighborhood{R} &lt;: AbstractRadialNeighborhood{R}</code></pre><p>Radial neighborhoods calculate the surrounding neighborood from the radius around the central cell. The central cell is ommitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/neighborhoods.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractCustomNeighborhood" href="#DynamicGrids.AbstractCustomNeighborhood"><code>DynamicGrids.AbstractCustomNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractCustomNeighborhood &lt;: Neighborhood{R}</code></pre><p>Custom neighborhoods are tuples of custom coordinates (also tuples) specified in relation to the central point of the current cell. They can be any arbitrary shape or size, but should be listed in column-major order for performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/neighborhoods.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CustomNeighborhood" href="#DynamicGrids.CustomNeighborhood"><code>DynamicGrids.CustomNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Allows completely arbitrary neighborhood shapes by specifying each coordinate specifically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.LayeredCustomNeighborhood" href="#DynamicGrids.LayeredCustomNeighborhood"><code>DynamicGrids.LayeredCustomNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sets of custom neighborhoods that can have separate rules for each set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.neighbors" href="#DynamicGrids.neighbors"><code>DynamicGrids.neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><p>neighbors(hood::Neighborhood, buffer)</p><p>Returns an iteraterable over all cells in the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/interface.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sumneighbors" href="#DynamicGrids.sumneighbors"><code>DynamicGrids.sumneighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sumneighbors(hood::Neighborhood, buffer, state)</p><p>Sums all cells in the neighborhood. This is identical to running  <code>sum(neighbors(hood, buffer))</code> but it can be more efficient than as it may use matrix algra libraries for <code>sum</code>, instead of regular sum over  an iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/interface.jl#L50-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.mapsetneighbor!" href="#DynamicGrids.mapsetneighbor!"><code>DynamicGrids.mapsetneighbor!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapsetneighbor!(data, hood, rule, state, index)</code></pre><p>Run <code>setneighbor!</code> over all cells in the neighborhood and sums its return values. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/interface.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.setneighbor!" href="#DynamicGrids.setneighbor!"><code>DynamicGrids.setneighbor!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Set value of a cell in the neighborhood. Called in <code>mapsetneighbor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/interface.jl#L67-L69">source</a></section></article><h2 id="Output-1"><a class="docs-heading-anchor" href="#Output-1">Output</a><a class="docs-heading-anchor-permalink" href="#Output-1" title="Permalink"></a></h2><h3 id="Output-Types-and-Constructors-1"><a class="docs-heading-anchor" href="#Output-Types-and-Constructors-1">Output Types and Constructors</a><a class="docs-heading-anchor-permalink" href="#Output-Types-and-Constructors-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Output" href="#DynamicGrids.Output"><code>DynamicGrids.Output</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Output &lt;: AbstractArray{T,1}</code></pre><p>Outputs are store or display simulation results, usually as a vector of grids, one for each timestep - but they may also sum, combine or otherise manipulate the simulation grids to improve performance, reduce memory overheads or similar.</p><p>Simulation outputs are decoupled from simulation behaviour, and in many cases can be used interchangeably.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ArrayOutput" href="#DynamicGrids.ArrayOutput"><code>DynamicGrids.ArrayOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A simple output that stores each step of the simulation in a vector of arrays.</p><p><strong>Arguments:</strong></p><ul><li><code>frames</code>: Single init array or vector of arrays</li><li><code>length</code>: The length of the output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GraphicOutput" href="#DynamicGrids.GraphicOutput"><code>DynamicGrids.GraphicOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type GraphicOutput &lt;: Output{T}</code></pre><p>Outputs that display the simulation frames live.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/graphic.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.REPLOutput" href="#DynamicGrids.REPLOutput"><code>DynamicGrids.REPLOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An output that is displayed directly in the REPL. It can either store or discard simulation frames.</p><p><strong>Arguments:</strong></p><ul><li><code>frames</code>: Single init array or vector of arrays</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>fps::Real</code>: frames per second to run at</li><li><code>showfps::Real</code>: maximum displayed frames per second</li><li><code>store::Bool</code>: store frames or not</li><li><code>color</code>: a color from Crayons.jl</li><li><code>cutoff::Real</code>: the cutoff point to display a full or empty cell. Default is <code>0.5</code></li><li><code>style::CharStyle</code>: <code>Block()</code> or <code>Braile()</code> style printing. <code>Braile</code> uses 1/4 the screen space.</li></ul><pre><code class="language-julia">REPLOutput(init)</code></pre><p>The default option is <code>:block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ImageOutput" href="#DynamicGrids.ImageOutput"><code>DynamicGrids.ImageOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ImageOutput &lt;: GraphicOutput{T}</code></pre><p>Graphic outputs that display the simulation grid(s) as RGB24 images.</p><p>Although the majority of the code is maintained here to enable sharing and reuse, no <code>ImageOutput</code>s are provided in DynamicGrids.jl to avoid heavey dependencies on graphics libraries. See <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> and <a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a> for implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L4-L13">source</a></section></article><p>Dynamic grids uses <a href="https://github.com/rafaqz/Mixers.jl">Mixers.jl</a> mixins to simplify specifying custom outputs with the required fields.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.@Output" href="#DynamicGrids.@Output"><code>DynamicGrids.@Output</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Mixin of basic fields for all outputs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.@Graphic" href="#DynamicGrids.@Graphic"><code>DynamicGrids.@Graphic</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Mixin for graphic output fields</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/graphic.jl#L18-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.@Image" href="#DynamicGrids.@Image"><code>DynamicGrids.@Image</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Mixin fields for <code>ImageOutput</code>s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L34-L36">source</a></section></article><h3 id="Grid-processors-1"><a class="docs-heading-anchor" href="#Grid-processors-1">Grid processors</a><a class="docs-heading-anchor-permalink" href="#Grid-processors-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GridProcessor" href="#DynamicGrids.GridProcessor"><code>DynamicGrids.GridProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type GridProcessor</code></pre><p>Grid processors convert a frame of the simulation into an RGB24 image for display. Frames may hold one or multiple grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L82-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SingleGridProcessor" href="#DynamicGrids.SingleGridProcessor"><code>DynamicGrids.SingleGridProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type SingleGridProcessor &lt;: GridProcessor</code></pre><p>Grid processors that convert one grid to an image.</p><p>The first grid will be displayed if a SingleGridProcessor is used with a NamedTuple of grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ColorProcessor" href="#DynamicGrids.ColorProcessor"><code>DynamicGrids.ColorProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>&quot;     ColorProcessor(; scheme=Greyscale(), zerocolor=nothing, maskcolor=nothing)</p><p>Converts output grids to a colorsheme.</p><p><strong>Arguments / Keyword Arguments</strong></p><ul><li><code>scheme</code>: a ColorSchemes.jl colorscheme.</li><li><code>zerocolor</code>: an <code>RGB24</code> color to use when values are zero, or <code>nothing</code> to ignore.</li><li><code>maskcolor</code>: an <code>RGB24</code> color to use when cells are masked, or <code>nothing</code> to ignore.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.MultiGridProcessor" href="#DynamicGrids.MultiGridProcessor"><code>DynamicGrids.MultiGridProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type MultiGridProcessor &lt;: GridProcessor</code></pre><p>Processors that convert multiple grids to a single image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L127-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ThreeColorProcessor" href="#DynamicGrids.ThreeColorProcessor"><code>DynamicGrids.ThreeColorProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ThreeColorProcessor(; colors=(Red(), Green(), Blue()), zerocolor=nothing, maskcolor=nothing)</code></pre><p>Assigns <code>Red()</code>, <code>Blue()</code>, <code>Green()</code> or <code>nothing</code> to any number of dynamic grids in any order. Duplicate colors will be summed. The final color sums are combined into a composite color image for display.</p><p><strong>Arguments / Keyword Arguments</strong></p><ul><li><code>colors</code>: a tuple or <code>Red()</code>, <code>Green()</code>, <code>Blue()</code>, or <code>nothing</code> matching the number of grids.</li><li><code>zerocolor</code>: an <code>RGB24</code> color to use when values are zero, or <code>nothing</code> to ignore.</li><li><code>maskcolor</code>: an <code>RGB24</code> color to use when cells are masked, or <code>nothing</code> to ignore.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.LayoutProcessor" href="#DynamicGrids.LayoutProcessor"><code>DynamicGrids.LayoutProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LayoutProcessor(layout::Array, processors)     LayoutProcessor(reshape(layout, length(layout), 1), processors)</p><p>LayoutProcessor allows displaying multiple grids in a block layout, by specifying a layout matrix and a list of SingleGridProcessors to be run for each.</p><p><strong>Arguments / Keyword arguments</strong></p><ul><li><code>layout</code>: A Vector or Matrix containing the keys or numbers of grids in the locations to display them. <code>nothing</code>, <code>missing</code> or <code>0</code> values will be skipped.</li><li><code>processors</code>: tuple of SingleGridProcessor, one for each grid in the simulation. Can be <code>nothing</code> or any other value for grids not in layout.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Greyscale" href="#DynamicGrids.Greyscale"><code>DynamicGrids.Greyscale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Greyscale{M1, M2}</code></pre><p>Default colorscheme. Better performance than using a Colorschemes.jl scheme as there is no interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L66-L69">source</a></section></article><h3 id="Gifs-1"><a class="docs-heading-anchor" href="#Gifs-1">Gifs</a><a class="docs-heading-anchor-permalink" href="#Gifs-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.savegif" href="#DynamicGrids.savegif"><code>DynamicGrids.savegif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">savegif(filename::String, o::Output, data; [processor=processor(o)], [kwargs...])</code></pre><p>Write the output array to a gif. You must pass a processor keyword argument for any <code>Output</code> objects not in <code>ImageOutput</code> (which allready have a processor attached).</p><p>Saving very large gifs may trigger a bug in Imagemagick.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L306-L313">source</a></section></article><h2 id="Overflow-1"><a class="docs-heading-anchor" href="#Overflow-1">Overflow</a><a class="docs-heading-anchor-permalink" href="#Overflow-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Overflow" href="#DynamicGrids.Overflow"><code>DynamicGrids.Overflow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Overflow</code></pre><p>Singleton types for choosing the grid overflow rule used in <a href="#DynamicGrids.inbounds-Tuple{Tuple,Tuple,Any}"><code>inbounds</code></a>. These determine what is done when a neighborhood or jump extends outside of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/rulesets.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.WrapOverflow" href="#DynamicGrids.WrapOverflow"><code>DynamicGrids.WrapOverflow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct WrapOverflow &lt;: Overflow</code></pre><p>Wrap cords that overflow boundaries back to the opposite side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/rulesets.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RemoveOverflow" href="#DynamicGrids.RemoveOverflow"><code>DynamicGrids.RemoveOverflow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RemoveOverflow &lt;: Overflow</code></pre><p>Remove coords that overflow boundaries</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/rulesets.jl#L11">source</a></section></article><h2 id="Internal-data-handling-1"><a class="docs-heading-anchor" href="#Internal-data-handling-1">Internal data handling</a><a class="docs-heading-anchor-permalink" href="#Internal-data-handling-1" title="Permalink"></a></h2><p>Simdata and Griddata objects are used to manage the simulation and provide rules with any data they need.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SimData" href="#DynamicGrids.SimData"><code>DynamicGrids.SimData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SimData{I, D, Ru, STi, CTi, CFr} &lt;: AbstractSimData</code></pre><p>Simulation data hold all intermediate arrays, timesteps and frame numbers for the current frame of the siulation.</p><p>A simdata object is accessable in <code>applyrule</code> as the second parameter.</p><p>Multiple grids can be indexed into using their key. Single grids can be indexed as if SimData is regular array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/simulationdata.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GridData" href="#DynamicGrids.GridData"><code>DynamicGrids.GridData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type GridData &lt;: AbstractArray{T,N}</code></pre><p>Simulation data specific to a singule grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/simulationdata.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ReadableGridData" href="#DynamicGrids.ReadableGridData"><code>DynamicGrids.ReadableGridData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simulation data and storage passed to rules for each timestep.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/simulationdata.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.WritableGridData" href="#DynamicGrids.WritableGridData"><code>DynamicGrids.WritableGridData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>WriteableGridData is passed to rules <code>&lt;: PartialRule</code>, and can be written to directly as an array. This handles updates to block optimisations and writing to the correct source/dest array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/simulationdata.jl#L83-L87">source</a></section></article><h1 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.VonNeumannNeighborhood-Tuple{}" href="#DynamicGrids.VonNeumannNeighborhood-Tuple{}"><code>DynamicGrids.VonNeumannNeighborhood</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A convenience wrapper to build a VonNeumann neighborhoods as a <code>CustomNeighborhood</code>.</p><p>TODO: variable radius</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/neighborhoods.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.resume!-Tuple{Output,Ruleset}" href="#DynamicGrids.resume!-Tuple{Output,Ruleset}"><code>DynamicGrids.resume!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resume!(output::Output, ruleset::Ruleset;
        tstop=stoptime(output),
        fps=fps(output),
        simdata=nothing,
        nreplicates=nothing)</code></pre><p>Restart the simulation where you stopped last time. For arguments see <a href="#DynamicGrids.sim!-Tuple{Output,Ruleset}"><code>sim!</code></a>. The keyword arg <code>tadd</code> indicates the number of grid frames to add, and of course an init array will not be accepted.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: An <a href="#DynamicGrids.Output"><code>Output</code></a> to store grids or display them on the screen.</li><li><code>ruleset</code>: A <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> containing one ore more <a href="#DynamicGrids.Rule"><code>Rule</code></a>s. These will each be run in sequence.</li></ul><p><strong>Keyword Arguments (optional</strong></p><ul><li><code>init</code>: the initialisation array. If not passed, the <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> must contain an <code>init</code> array.</li><li><code>tstop</code>: the stop time for the simulation. Taken from the output length if not passed in.</li><li><code>fps</code>: the frames per second to display. Taken from the output if not passed in.</li><li><code>nreplicates</code>: the number of replicates to combine in stochastic simulations</li><li><code>simdata</code>: a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object. Keeping it between simulations can reduce memory allocation when that is important.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/framework.jl#L59-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.savegif" href="#DynamicGrids.savegif"><code>DynamicGrids.savegif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">savegif(filename::String, o::Output, data; [processor=processor(o)], [kwargs...])</code></pre><p>Write the output array to a gif. You must pass a processor keyword argument for any <code>Output</code> objects not in <code>ImageOutput</code> (which allready have a processor attached).</p><p>Saving very large gifs may trigger a bug in Imagemagick.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L306-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sim!-Tuple{Output,Ruleset}" href="#DynamicGrids.sim!-Tuple{Output,Ruleset}"><code>DynamicGrids.sim!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sim!(output, ruleset;
     init=nothing,
     tstpan=(1, length(output)),
     fps=fps(output),
     simdata=nothing,
     nreplicates=nothing)</code></pre><p>Runs the whole simulation, passing the destination aray to the passed in output for each time-step.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: An <a href="#DynamicGrids.Output"><code>Output</code></a> to store grids or display them on the screen.</li><li><code>ruleset</code>: A <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> containing one ore more <a href="#DynamicGrids.Rule"><code>Rule</code></a>s. These will each be run in sequence.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>init</code>: the initialisation array. If not passed, the <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> must contain an <code>init</code> array.</li><li><code>tspan</code>: a tuple holding the start and end of the timespan the simulaiton will run for. Taken from the output length if not passed in.</li><li><code>fps</code>: the frames per second to display. Will be taken from the output if not passed in.</li><li><code>nreplicates</code>: the number of replicates to combine in stochastic simulations</li><li><code>simdata</code>: a <a href="#DynamicGrids.SimData"><code>SimData</code></a> object. Keeping it between simulations can reduce memory allocation when that is important.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/framework.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule-Tuple{Chain,SimData,Any,Any,Vararg{Any,N} where N}" href="#DynamicGrids.applyrule-Tuple{Chain,SimData,Any,Any,Vararg{Any,N} where N}"><code>DynamicGrids.applyrule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">applyrule(rules::Chain, data, state, (i, j))</code></pre><p>Chained rules. If a <a href="#DynamicGrids.Chain"><code>Chain</code></a> of rules is passed to <code>applyrule</code>, run them sequentially for each cell. This can have much beter performance as no writes occur between rules, and they are essentially compiled together into compound rules. This gives correct results only for <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>, or for a single <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> followed by <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/chain.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.combinebands-Tuple{Any,Any}" href="#DynamicGrids.combinebands-Tuple{Any,Any}"><code>DynamicGrids.combinebands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">combinebands(c::Tuple{Vararg{&lt;:BandColor}, acc, xs)</code></pre><p>Assign values to color bands given in any order, and output as RGB24.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L369-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.delay-Tuple{Output,Any}" href="#DynamicGrids.delay-Tuple{Output,Any}"><code>DynamicGrids.delay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delay(o::Output, f)</code></pre><p><code>Graphic</code> outputs delay the simulations to match some <code>fps</code> rate, but other outputs just do nothing and continue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.finalise-Tuple{Output}" href="#DynamicGrids.finalise-Tuple{Output}"><code>DynamicGrids.finalise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">finalise(o::Output)</code></pre><p>Finalise the output display, if it has one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.grid2image" href="#DynamicGrids.grid2image"><code>DynamicGrids.grid2image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grid2image(o::ImageOutput, data::Union{Ruleset,SimData}, grid, t::Integer)
grid2image(p::GridProcessor, minval, maxval, data::Union{Ruleset,SimData}, grids, t)</code></pre><p>Convert a grid or named tuple of grids to an RGB24 image, using a GridProcessor</p><p><a href="@reg"><code>GridProcessor</code></a> is intentionally not dispatched with the output type in the methods that finally generate images, to reduce coupling. But it they can be distpatched on together when required for custom outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L88-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.hoodsize-Tuple{Neighborhood}" href="#DynamicGrids.hoodsize-Tuple{Neighborhood}"><code>DynamicGrids.hoodsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hoodsize(radius)</code></pre><p>Get the size of a neighborhood dimension from its radius, which is always 2r + 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/neighborhoods.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.inbounds-Tuple{Tuple,Tuple,Any}" href="#DynamicGrids.inbounds-Tuple{Tuple,Tuple,Any}"><code>DynamicGrids.inbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inbounds(x, max, overflow)</code></pre><p>Check grid boundaries for a single coordinate and max value or a tuple of coorinates and max values.</p><p>Returns a tuple containing the coordinate(s) followed by a boolean <code>true</code> if the cell is in bounds, <code>false</code> if not.</p><p>Overflow of type <a href="#DynamicGrids.RemoveOverflow"><code>RemoveOverflow</code></a> returns the coordinate and <code>false</code> to skip coordinates that overflow outside of the grid. <a href="#DynamicGrids.WrapOverflow"><code>WrapOverflow</code></a> returns a tuple with the current position or it&#39;s wrapped equivalent, and <code>true</code> as it is allways in-bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/utils.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.initgrids!-Tuple{Output,Any}" href="#DynamicGrids.initgrids!-Tuple{Output,Any}"><code>DynamicGrids.initgrids!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Grids are preallocated and reused.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L145-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.initialise-Tuple{Output}" href="#DynamicGrids.initialise-Tuple{Output}"><code>DynamicGrids.initialise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initialise(o::Output)</code></pre><p>Initialise the output display, if it has one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isasync-Tuple{Output}" href="#DynamicGrids.isasync-Tuple{Output}"><code>DynamicGrids.isasync</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isasync(o::Output)</code></pre><p>Check if the output should run asynchonously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ismasked-Tuple{AbstractSimData,Vararg{Any,N} where N}" href="#DynamicGrids.ismasked-Tuple{AbstractSimData,Vararg{Any,N} where N}"><code>DynamicGrids.ismasked</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check if a cell is masked, using the passed-in mask grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/utils.jl#L37-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isshowable-Tuple{Output,Any}" href="#DynamicGrids.isshowable-Tuple{Output,Any}"><code>DynamicGrids.isshowable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isshowable(o::Output)</code></pre><p>Check if the output can be shown visually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.isstored-Tuple{Output}" href="#DynamicGrids.isstored-Tuple{Output}"><code>DynamicGrids.isstored</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isasync(o::Output)</code></pre><p>Check if the output is storing each grid frame, or just the the current one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.normalise-Tuple{Any,Number,Number}" href="#DynamicGrids.normalise-Tuple{Any,Number,Number}"><code>DynamicGrids.normalise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalise(x, min, max)</code></pre><p>Set a value to be between zero and one, before converting to Color. min and max of <code>nothing</code> are assumed to be 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L326-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.precalcrules" href="#DynamicGrids.precalcrules"><code>DynamicGrids.precalcrules</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precalcrules(rule, data)</code></pre><p>Run any precalculations needed to run a rule for a particular frame, returning new rule objects containing the updates.</p><p>This is a functional approach, rebuilding rules recursively. <code>@set</code> from Setfield.jl can help updating immutable rules.</p><p>The default action is to return the existing rule without change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/interface.jl#L30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.radius" href="#DynamicGrids.radius"><code>DynamicGrids.radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">radius(rule, [key])</code></pre><p>Return the radius of a rule or ruleset if it has one, otherwise zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/interface.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.radius-Tuple{Ruleset}" href="#DynamicGrids.radius-Tuple{Ruleset}"><code>DynamicGrids.radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the largest radius present in the passed in rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/neighborhoods.jl#L126-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.rgb24-Tuple{Any,Any}" href="#DynamicGrids.rgb24-Tuple{Any,Any}"><code>DynamicGrids.rgb24</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rgb24(scheme, val)</code></pre><p>Convert a color scheme and value to an RGB24 value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.rgb24-Tuple{Tuple}" href="#DynamicGrids.rgb24-Tuple{Tuple}"><code>DynamicGrids.rgb24</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rgb24(val)</code></pre><p>Convert a number, tuple or color to an RGB24 value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L352-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.scale-Tuple{Any,Any,Any}" href="#DynamicGrids.scale-Tuple{Any,Any,Any}"><code>DynamicGrids.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale(x, min, max)</code></pre><p>Rescale a value between 0 and 1 to be between <code>min</code> and <code>max</code>. This can be used to shrink the range of a colorsheme that is displayed. min and max of <code>nothing</code> are assumed to be 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L340-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.showgrid-Tuple{Output,Vararg{Any,N} where N}" href="#DynamicGrids.showgrid-Tuple{Output,Vararg{Any,N} where N}"><code>DynamicGrids.showgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">showgrid(o::Output, args...)</code></pre><p>Show the grid(s) in the output, if it can do that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/output.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.showimage" href="#DynamicGrids.showimage"><code>DynamicGrids.showimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showimage(image, output, f, t)</code></pre><p>Show image generated by and <code>GridProcessor</code> in an ImageOutput.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/2410f5ba412129b712e7de897cef1a8c764caae4/src/outputs/image.jl#L58-L62">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 14 May 2020 02:41">Thursday 14 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
