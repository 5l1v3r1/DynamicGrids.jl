<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cellular Â· Cellular.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Cellular.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Cellular</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Models-and-rules-1">Models and rules</a></li><li><a class="toctext" href="#Neighborhoods-1">Neighborhoods</a></li><li><a class="toctext" href="#Simulations-1">Simulations</a></li><li><a class="toctext" href="#Output-1">Output</a></li><li><a class="toctext" href="#Overflow-1">Overflow</a></li><li class="toplevel"><a class="toctext" href="#Customisation-1">Customisation</a></li><li><a class="toctext" href="#Framework-1">Framework</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Cellular</a></li></ul><a class="edit-page" href="https://github.com/rafaqz/Cellular.jl/blob/master/docs/src/index.md"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Cellular</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Cellular.jl-1" href="#Cellular.jl-1">Cellular.jl</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular" href="#Cellular"><code>Cellular</code></a> â€” <span class="docstring-category">Module</span>.</div><div><p>Cellular provides a framework for building grid based simulations. Everything can be customised and added to, but there are some central idea that define how a Cellular simulation works: <em>models</em>, <em>rules</em> and <em>neighborhoods</em>. For input and output of data their are  <em>init</em> arrays and <em>outputs</em>. </p><p>Models hold the configuration for a simulation, and trigger a specific <code>rule</code> method  that operates on each of the cells in the grid. See <a href="index.html#Cellular.AbstractModel"><code>AbstractModel</code></a> and  <a href="index.html#Cellular.rule"><code>rule</code></a>. Rules often trigger <a href="index.html#Cellular.neighbors"><code>neighbors</code></a> methods that sum surrounding cell  <em>neighborhoods</em> (<a href="index.html#Cellular.AbstractNeighborhood"><code>AbstractNeighborhood</code></a>), such as Moore and Von Neumann neighborhoods.</p><p>Outputs are ways of storing of viewing the simulation, and can be used interchangeably  depending on your needs. See <a href="index.html#Cellular.AbstractOutput"><code>AbstractOutput</code></a>.</p><p>The inititialisation array may be any AbstractArray, containing whatever initialisation data is required to start the simulation. Most rules work on two-dimensional arrays, but one-dimensional  arrays are also use for some cellular automata. </p><p>A typical simulation is run with a script like:</p><pre><code class="language-julia">init = my_array
model = Life()
output = REPLOutput(init)

sim!(output, model, init)</code></pre><p>Multiple models can be passed to  <code>sim!()</code> in a tuple, and each of their rules will be run for the whole grid in sequence.</p><pre><code class="language-julia">sim!(output, (model1, model2), init)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/Cellular.jl#L2-L36">source</a></section><ul><li><a href="index.html#Cellular.jl-1">Cellular.jl</a></li><ul><li><a href="index.html#Example-1">Example</a></li><li><a href="index.html#Models-and-rules-1">Models and rules</a></li><li><a href="index.html#Neighborhoods-1">Neighborhoods</a></li><li><a href="index.html#Simulations-1">Simulations</a></li><li><a href="index.html#Output-1">Output</a></li><li><a href="index.html#Overflow-1">Overflow</a></li></ul><li><a href="index.html#Customisation-1">Customisation</a></li><ul><li><a href="index.html#Framework-1">Framework</a></li></ul></ul><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>This example runs a game of life simulation, and uses the REPLOutput to print the  frame directly in the REPL. You could instead use <code>output = GtkOutput(init)</code> for animation.</p><div><pre><code class="language-julia">using Cellular

# Build a random starting grid
init = round.(Int8, max.(0.0, rand(-2.0:0.1:1.0, 70,70)))

# Use the default game of life model
model = Life()

# Use an output that shows the cellular automata in the REPL
output = REPLOutput(init)

sim!(output, model, init; time=1:5)</code></pre><pre><code class="language-none">[0;0H[1;0H[2K[2;0H[2K[3;0H[2K[4;0H[2K[5;0H[2K[6;0H[2K[7;0H[2K[8;0H[2K[9;0H[2K[10;0H[2K[11;0H[2K[12;0H[2K[13;0H[2K[14;0H[2K[15;0H[2K[16;0H[2K[17;0H[2K[18;0H[2K[19;0H[2K[20;0H[2K[21;0H[2K[22;0H[2K[23;0H[2K[24;0H[2K[25;0H[2K[26;0H[2K[27;0H[2K[28;0H[2K[29;0H[2K[30;0H[2K[31;0H[2K[32;0H[2K[33;0H[2K[34;0H[2K[35;0H[2K[36;0H[2K[37;0H[2K[38;0H[2K[39;0H[2K[40;0H[2K[41;0H[2K[42;0H[2K[43;0H[2K[44;0H[2K[45;0H[2K[46;0H[2K[47;0H[2K[48;0H[2K[49;0H[2K[50;0H[2K[0;0H[1;0H[2K[2;0H[2K[3;0H[2K[4;0H[2K[5;0H[2K[6;0H[2K[7;0H[2K[8;0H[2K[9;0H[2K[10;0H[2K[11;0H[2K[12;0H[2K[13;0H[2K[14;0H[2K[15;0H[2K[16;0H[2K[17;0H[2K[18;0H[2K[19;0H[2K[20;0H[2K[21;0H[2K[22;0H[2K[23;0H[2K[24;0H[2K[25;0H[2K[26;0H[2K[27;0H[2K[28;0H[2K[29;0H[2K[30;0H[2K[31;0H[2K[32;0H[2K[33;0H[2K[34;0H[2K[35;0H[2K[36;0H[2K[37;0H[2K[38;0H[2K[39;0H[2K[40;0H[2K[41;0H[2K[42;0H[2K[43;0H[2K[44;0H[2K[45;0H[2K[46;0H[2K[47;0H[2K[48;0H[2K[49;0H[2K[50;0H[2K[0;0H[1;0H[2K[2;0H[2K[3;0H[2K[4;0H[2K[5;0H[2K[6;0H[2K[7;0H[2K[8;0H[2K[9;0H[2K[10;0H[2K[11;0H[2K[12;0H[2K[13;0H[2K[14;0H[2K[15;0H[2K[16;0H[2K[17;0H[2K[18;0H[2K[19;0H[2K[20;0H[2K[21;0H[2K[22;0H[2K[23;0H[2K[24;0H[2K[25;0H[2K[26;0H[2K[27;0H[2K[28;0H[2K[29;0H[2K[30;0H[2K[31;0H[2K[32;0H[2K[33;0H[2K[34;0H[2K[35;0H[2K[36;0H[2K[37;0H[2K[38;0H[2K[39;0H[2K[40;0H[2K[41;0H[2K[42;0H[2K[43;0H[2K[44;0H[2K[45;0H[2K[46;0H[2K[47;0H[2K[48;0H[2K[49;0H[2K[50;0H[2K[0;0H[1;0H[2K[2;0H[2K[3;0H[2K[4;0H[2K[5;0H[2K[6;0H[2K[7;0H[2K[8;0H[2K[9;0H[2K[10;0H[2K[11;0H[2K[12;0H[2K[13;0H[2K[14;0H[2K[15;0H[2K[16;0H[2K[17;0H[2K[18;0H[2K[19;0H[2K[20;0H[2K[21;0H[2K[22;0H[2K[23;0H[2K[24;0H[2K[25;0H[2K[26;0H[2K[27;0H[2K[28;0H[2K[29;0H[2K[30;0H[2K[31;0H[2K[32;0H[2K[33;0H[2K[34;0H[2K[35;0H[2K[36;0H[2K[37;0H[2K[38;0H[2K[39;0H[2K[40;0H[2K[41;0H[2K[42;0H[2K[43;0H[2K[44;0H[2K[45;0H[2K[46;0H[2K[47;0H[2K[48;0H[2K[49;0H[2K[50;0H[2K[0;0H[1;0H[2K[2;0H[2K[3;0H[2K[4;0H[2K[5;0H[2K[6;0H[2K[7;0H[2K[8;0H[2K[9;0H[2K[10;0H[2K[11;0H[2K[12;0H[2K[13;0H[2K[14;0H[2K[15;0H[2K[16;0H[2K[17;0H[2K[18;0H[2K[19;0H[2K[20;0H[2K[21;0H[2K[22;0H[2K[23;0H[2K[24;0H[2K[25;0H[2K[26;0H[2K[27;0H[2K[28;0H[2K[29;0H[2K[30;0H[2K[31;0H[2K[32;0H[2K[33;0H[2K[34;0H[2K[35;0H[2K[36;0H[2K[37;0H[2K[38;0H[2K[39;0H[2K[40;0H[2K[41;0H[2K[42;0H[2K[43;0H[2K[44;0H[2K[45;0H[2K[46;0H[2K[47;0H[2K[48;0H[2K[49;0H[2K[50;0H[2KCellular.REPLOutput{Cellular.ArrayOutput{Array{Int8,2}}}</code></pre></div><p>More life-like examples (gleaned from CellularAutomata.jl):</p><pre><code class="language-julia"># Morley
sim!(output, Life(b=[3,6,8], s=[2,4,5]), init; pause=0.1)

# 2x2
sim!(output, Life(b=[3,6], s=[1,2,5]), init; pause=0.05)

# Dimoeba
init1 = round.(Int8, max.(0.0, rand(70,70)))
sim!(output, Life(b=[3,5,6,7,8], s=[5,6,7,8]), init1; pause=0.1)

## No death
sim!(output, Life(b=[3], s=[0,1,2,3,4,5,6,7,8]), init; pause=0.1)

## 34 life
sim!(output, Life(b=[3,4], s=[3,4]), init; pause=0.1)

# Replicator
init2 = round.(Int8, max.(0.0, rand(70,70)))
init2[:, 1:30] .= 0
init2[21:50, :] .= 0
sim!(output, Life(b=[1,3,5,7], s=[1,3,5,7]), init2; pause=0.1)</code></pre><h2><a class="nav-anchor" id="Models-and-rules-1" href="#Models-and-rules-1">Models and rules</a></h2><p>Models define simulation behaviour. They hold data relevant to the simulation, and trigger dispatch of particular <a href="index.html#Cellular.rule"><code>rule</code></a> methods. Models can be chained together arbitrarily to make composite simulations.</p><h3><a class="nav-anchor" id="Types-and-Constructors-1" href="#Types-and-Constructors-1">Types and Constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractModel" href="#Cellular.AbstractModel"><code>Cellular.AbstractModel</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractModel</code></pre><p>A model contains all the information required to run a rule in a cellular  simulation, given an initialised array. Models can be chained together in any order.</p><p>The output of the rule for an AbstractModel is written to the current cell in the grid.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractPartialModel" href="#Cellular.AbstractPartialModel"><code>Cellular.AbstractPartialModel</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractPartialModel</code></pre><p>An abstract type for models that do not write to every cell of the grid, for efficiency.</p><p>There are two main differences with <code>AbstractModel</code>. AbstractPartialModel requires initialisation of the destination array before each timestep, and the output of  the rule is not written to the grid but done manually.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L9-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractLife" href="#Cellular.AbstractLife"><code>Cellular.AbstractLife</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractLife &lt;: Cellular.AbstractModel</code></pre><p>Triggers dispatch on rule  for game of life simulations. Models that extend this should replicate the fields for <a href="index.html#Cellular.Life"><code>Life</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/life.jl#L1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.Life" href="#Cellular.Life"><code>Cellular.Life</code></a> â€” <span class="docstring-category">Type</span>.</div><div><p>Game-of-life style cellular automata. </p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/life.jl#L7">source</a></section><h3><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.rule" href="#Cellular.rule"><code>Cellular.rule</code></a> â€” <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">function rule(model, state, index, t, source, dest, args...)</code></pre><p>Rules alter cell values based on their current state and other cells, often <a href="index.html#Cellular.neighbors"><code>neighbors</code></a>. Most rules return a value to be written to the current cell, except rules for models inheriting from <a href="index.html#Cellular.AbstractPartialModel"><code>AbstractPartialModel</code></a>.  These must write to the <code>dest</code> array directly.</p><p><strong>Arguments:</strong></p><ul><li><p><code>model</code> : <a href="index.html#Cellular.AbstractModel"><code>AbstractModel</code></a> </p></li><li><p><code>state</code>: the value of the current cell</p></li><li><p><code>index</code>: a (row, column) tuple of Int for the current cell coordinates</p></li><li><p><code>t</code>: the current time step</p></li><li><p><code>source</code>: the whole source array. Not to be written to</p></li><li><p><code>dest</code>: the whole destination array. To be written to for AbstractPartialModel.</p></li><li><p><code>args</code>: additional arguments passed through from user input to <a href="index.html#Cellular.sim!"><code>sim!</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L82-L99">source</a><div><pre><code class="language-none">rule(model::AbstractLife, state, args...)</code></pre><p>Rule for game-of-life style cellular automata.</p><p>The cell becomes active if it is empty and the number of neightbors is a number in  the b array, and remains active the cell is active and the number of neightbors is  in the s array.</p><p>Returns: boolean</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/life.jl#L17-L26">source</a></section><h2><a class="nav-anchor" id="Neighborhoods-1" href="#Neighborhoods-1">Neighborhoods</a></h2><p>Neighborhoods define a pattern of cells surrounding the current cell,  and how they are combined to update the value of the current cell.</p><h3><a class="nav-anchor" id="Types-and-Constructors-2" href="#Types-and-Constructors-2">Types and Constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractNeighborhood" href="#Cellular.AbstractNeighborhood"><code>Cellular.AbstractNeighborhood</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractNeighborhood</code></pre><p>Abstract type to extend to a neighborhood</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L1">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractRadialNeighborhood" href="#Cellular.AbstractRadialNeighborhood"><code>Cellular.AbstractRadialNeighborhood</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractRadialNeighborhood{T} &lt;: Cellular.AbstractNeighborhood</code></pre><p>Abstract type to extend <a href="@ref"><code>RadialNeighborhoods</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.RadialNeighborhood" href="#Cellular.RadialNeighborhood"><code>Cellular.RadialNeighborhood</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct RadialNeighborhood{T, O} &lt;: Cellular.AbstractRadialNeighborhood{T}</code></pre><p>Radial neighborhoods calculate the surrounding neighborood from the radius around the central cell, with a number of variants. </p><p>They can be constructed with: <code>RadialNeighborhood{:moore,Skip}(1,Skip())</code> but the keyword  constructor should be preferable.</p><ul><li><p><code>radius</code></p><p>The &#39;radius&#39; of the neighborhood is the distance to the edge from the center cell. A neighborhood with radius 1 is 3 cells wide.</p></li></ul><ul><li><p><code>overflow</code></p><p><a href="index.html#Cellular.AbstractOverflow"><code>AbstractOverflow</code></a>. Determines how co-ordinates outside of the grid are handled</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L7-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.RadialNeighborhood-Tuple{}" href="#Cellular.RadialNeighborhood-Tuple{}"><code>Cellular.RadialNeighborhood</code></a> â€” <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">RadialNeighborhood(;typ = :moore, radius = 1, overflow = Skip)</code></pre><p>The radial neighborhood constructor with defaults.</p><p>This neighborhood can be used for one-dimensional, Moore, von Neumann or  Rotated von Neumann neigborhoods, and may have a radius of any integer size.</p><p><strong>Keyword Arguments</strong></p><ul><li><p>typ : A Symbol from :onedim, :moore, :vonneumann or :rotvonneumann. Default: :moore</p></li><li><p>radius: Int. Default: 1</p></li><li><p>overflow: <a href="index.html#Cellular.AbstractOverflow"><code>AbstractOverflow</code></a>. Default: Skip()</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L23-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractCustomNeighborhood" href="#Cellular.AbstractCustomNeighborhood"><code>Cellular.AbstractCustomNeighborhood</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractCustomNeighborhood &lt;: Cellular.AbstractNeighborhood</code></pre><p>Custom neighborhoods are tuples of custom coordinates in relation to the central point of the current cell. They can be any arbitrary shape or size.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L38-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.CustomNeighborhood" href="#Cellular.CustomNeighborhood"><code>Cellular.CustomNeighborhood</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct CustomNeighborhood{H, O} &lt;: Cellular.AbstractCustomNeighborhood</code></pre><p>Allows completely arbitrary neighborhood shapes by specifying each coordinate specifically.</p><ul><li><p><code>neighbors</code></p><p>A tuple of tuples of Int (or an array of arrays of Int, etc), contains 2-D coordinates relative to the central point</p></li></ul><ul><li><p><code>overflow</code></p><p><a href="index.html#Cellular.AbstractOverflow"><code>AbstractOverflow</code></a>. Determines how co-ordinates outside of the grid are handled</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L44-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.MultiCustomNeighborhood" href="#Cellular.MultiCustomNeighborhood"><code>Cellular.MultiCustomNeighborhood</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct MultiCustomNeighborhood{H, O} &lt;: Cellular.AbstractCustomNeighborhood</code></pre><p>Sets of custom neighborhoods that can have separate rules for each set.</p><ul><li><p><code>multineighbors</code></p><p>A tuple of tuple of tuples of Int (or an array of arrays of arrays of Int, etc), contains 2-D coordinates relative to the central point.</p></li></ul><ul><li><p><code>cc</code></p><p>A vector the length of the base multineighbors tuple, for intermediate storage</p></li><li><p><code>overflow</code></p><p><a href="index.html#Cellular.AbstractOverflow"><code>AbstractOverflow</code></a>. Determines how co-ordinates outside of the grid are handled</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L58-L60">source</a></section><h3><a class="nav-anchor" id="Methods-2" href="#Methods-2">Methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.neighbors" href="#Cellular.neighbors"><code>Cellular.neighbors</code></a> â€” <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">neighbors(hood::AbstractNeighborhood, state, index, t, source, args...)</code></pre><p>Checks all cells in neighborhood and combines them according to the particular neighborhood type.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L75-L79">source</a><div><pre><code class="language-none">neighbors(hood::AbstractRadialNeighborhood{:onedim}, state, index, t, source, args...)</code></pre><p>Sums single dimension radial neighborhoods. Commonly used by Wolfram.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L82-L85">source</a><div><pre><code class="language-none">neighbors(hood::AbstractRadialNeighborhood, state, index, t, source, args...)</code></pre><p>Sums 2-dimensional radial Nieghborhoods. Specific shapes like Moore and Von Neumann are determined by <a href="index.html#Cellular.inhood"><code>inhood</code></a>, as this method is general.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L99-L103">source</a><div><pre><code class="language-none">neighbors(hood::AbstractCustomNeighborhood, state, index, t, source, args...)</code></pre><p>Sum a single custom neighborhood.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L119-L122">source</a><div><pre><code class="language-none">neighbors(hood::MultiCustomNeighborhood, state, index, t, source, args...)</code></pre><p>Sum multiple custom neighborhoods separately.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L126-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.inhood" href="#Cellular.inhood"><code>Cellular.inhood</code></a> â€” <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">inhood(n::AbstractRadialNeighborhood{:moore}, p, q, row, col)</code></pre><p>Check cell is inside a Moore neighborhood. Always returns <code>true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L151-L154">source</a><div><pre><code class="language-none">inhood(n::AbstractRadialNeighborhood{:vonneumann}, p, q, row, col)</code></pre><p>Check cell is inside a Vonn-Neumann neighborhood, returning a boolean.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L156-L159">source</a><div><pre><code class="language-none">inhood(n::AbstractRadialNeighborhood{:rotvonneumann}, p, q, row, col)</code></pre><p>Check cell is inside a Rotated Von-Neumann neighborhood, returning a boolean.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/neighborhoods.jl#L162-L165">source</a></section><h2><a class="nav-anchor" id="Simulations-1" href="#Simulations-1">Simulations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.sim!" href="#Cellular.sim!"><code>Cellular.sim!</code></a> â€” <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sim!(output, model, init, args...; time=1:1000, pause=0.0)</code></pre><p>Runs the whole simulation, passing the destination aray to  the passed in output for each time-step.</p><p><strong>Arguments</strong></p><ul><li><p><code>output</code>: An <a href="@ref">AbstractOutput</a> to store frames or display them on the screen.</p></li><li><p><code>model</code>: A single <a href="index.html#Cellular.AbstractModel"><code>AbstractModel</code></a> or a tuple of models that will each be run in sequence.</p></li><li><p><code>init</code>: The initialisation array. </p></li><li><p><code>args</code>: Any additional user defined args are passed through to <a href="index.html#Cellular.rule"><code>rule</code></a> and  <a href="index.html#Cellular.neighbors"><code>neighbors</code></a> methods.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>time</code>: Any Iterable of Number. Default: 1:1000</p></li><li><p><code>pause</code>: A Number that specifies the pause beteen frames in seconds. Default: 0.0</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L19-L35">source</a></section><h2><a class="nav-anchor" id="Output-1" href="#Output-1">Output</a></h2><h3><a class="nav-anchor" id="Types-and-Constructors-3" href="#Types-and-Constructors-3">Types and Constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractOutput" href="#Cellular.AbstractOutput"><code>Cellular.AbstractOutput</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractOutput</code></pre><p>Simulation outputs are decoupled from simulation behaviour and can be used interchangeably. These outputs inherit from AbstractOutput.</p><p>Types that extend AbstractOutput define their own method for <a href="index.html#Cellular.update_output"><code>update_output</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractArrayOutput" href="#Cellular.AbstractArrayOutput"><code>Cellular.AbstractArrayOutput</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractArrayOutput &lt;: Cellular.AbstractOutput</code></pre><p>Abstract type parent for array outputs.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L18-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.ArrayOutput" href="#Cellular.ArrayOutput"><code>Cellular.ArrayOutput</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct ArrayOutput{A} &lt;: Cellular.AbstractArrayOutput</code></pre><p>A simple array output that stores each step of the simulation in an array of arrays.</p><ul><li><p><code>frames</code></p><p>An array that holds each frame of the simulation</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L23-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.ArrayOutput-Tuple{Any}" href="#Cellular.ArrayOutput-Tuple{Any}"><code>Cellular.ArrayOutput</code></a> â€” <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ArrayOutput(init)</code></pre><p>Constructor for ArrayOutput</p><p><strong>Arguments</strong></p><ul><li><p>init : the initialisation array</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L30-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.REPLOutput" href="#Cellular.REPLOutput"><code>Cellular.REPLOutput</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct REPLOutput{A} &lt;: Cellular.AbstractArrayOutput</code></pre><p>A wrapper for <a href="index.html#Cellular.ArrayOutput"><code>ArrayOutput</code></a> that is displayed as asccii blocks in the REPL.</p><ul><li><p><code>array_output</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L51-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.REPLOutput-Tuple{Any}" href="#Cellular.REPLOutput-Tuple{Any}"><code>Cellular.REPLOutput</code></a> â€” <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">REPLOutput(init)</code></pre><p>Constructor for REPLOutput</p><p><strong>Arguments</strong></p><ul><li><p>init: The initialisation array</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L58-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.GtkOutput" href="#Cellular.GtkOutput"><code>Cellular.GtkOutput</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct GtkOutput{W, C, D} &lt;: Cellular.AbstractOutput</code></pre><p>Plot output live to a Gtk window.</p><ul><li><p><code>window</code></p></li><li><p><code>canvas</code></p></li><li><p><code>scaling</code></p></li><li><p><code>ok</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L119-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.GtkOutput-Tuple{Any}" href="#Cellular.GtkOutput-Tuple{Any}"><code>Cellular.GtkOutput</code></a> â€” <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">GtkOutput(init; scaling = 2)</code></pre><p>Constructor for GtkOutput.</p><ul><li><p><code>init::AbstractArray</code>: the same <code>init</code> array that will also be passed to sim!()</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L129-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.PlotsOutput" href="#Cellular.PlotsOutput"><code>Cellular.PlotsOutput</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct PlotsOutput{P} &lt;: Cellular.AbstractOutput</code></pre><p>A Plots.jl Output to plot cells as a heatmap in any Plots backend. Some backends (such as plotly) may be very slow to refresh. Others like gr() should be fine. <code>using Plots</code> must be called for this to be available.</p><ul><li><p><code>plot</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.PlotsOutput-Tuple{Any}" href="#Cellular.PlotsOutput-Tuple{Any}"><code>Cellular.PlotsOutput</code></a> â€” <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">PlotsOutput(init)</code></pre><p>Constructor for GtkOutput.</p><ul><li><p><code>init::AbstractArray</code>: the <code>init</code> array that will also be passed to sim!()</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L1-L5">source</a></section><h3><a class="nav-anchor" id="Methods-3" href="#Methods-3">Methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.update_output" href="#Cellular.update_output"><code>Cellular.update_output</code></a> â€” <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">update_output(output, frame, t, pause)</code></pre><p>Methods that update the output with the current frame, for timestep t.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L9-L12">source</a><div><pre><code class="language-none">update_output(output::AbstractArrayOutput, frame, t, pause)</code></pre><p>Copies the current frame unchanged to the storage array</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L38-L41">source</a><div><pre><code class="language-none">update_output(output::REPLOutput, frame, t, pause)</code></pre><p>Extends update_output from <a href="@ref"><code>ArrayOuput</code></a> by also printing to the REPL.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L69-L72">source</a><div><pre><code class="language-none">update_output(output::GtkOutput, frame, t, pause)</code></pre><p>Send current frame to the canvas in a Gtk window.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L151-L154">source</a><div><pre><code class="language-none">update_output(output::PlotsOutput, frame, t, pause)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L1-L3">source</a></section><h2><a class="nav-anchor" id="Overflow-1" href="#Overflow-1">Overflow</a></h2><p>Your grids have edges. When neighborhood or spotting activities overflow past edge,  you need a rule for deciding what to do.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.AbstractOverflow" href="#Cellular.AbstractOverflow"><code>Cellular.AbstractOverflow</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">abstract AbstractOverflow</code></pre><p>Singleton types for choosing the grid overflow rule used in <a href="index.html#Cellular.inbounds"><code>inbounds</code></a>. These determine what is done when a neighborhood  or jump extends outside of the grid.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L102-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.Wrap" href="#Cellular.Wrap"><code>Cellular.Wrap</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct Wrap &lt;: Cellular.AbstractOverflow</code></pre><p>Wrap cords that overflow to the opposite side</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.Skip" href="#Cellular.Skip"><code>Cellular.Skip</code></a> â€” <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct Skip &lt;: Cellular.AbstractOverflow</code></pre><p>Skip coords that overflow boundaries</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L110">source</a></section><h1><a class="nav-anchor" id="Customisation-1" href="#Customisation-1">Customisation</a></h1><p>Functions listed can be overridden or have methods added to them to modify simulation behaviour. Preferably create your own types of Model, Neighborhood or Output, and add methods for functions that dispatch on those types. If your new times and methods add useful functionality, consider making it publicly available by making pull request, or creating your own package that depends on Cellular.jl.</p><p>These are some more low-level functions you may also want to understand, if not actually modify extend.</p><h2><a class="nav-anchor" id="Framework-1" href="#Framework-1">Framework</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.broadcast_rules!" href="#Cellular.broadcast_rules!"><code>Cellular.broadcast_rules!</code></a> â€” <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">broadcast_rules!(models, source, dest, index, t, args...)</code></pre><p>Runs the rule(s) for each cell in the grid, dependin on the model(s) passed in.  For [<code>AbstractModel</code>] the returned values are written to the <code>dest</code> grid,  while for <a href="index.html#Cellular.AbstractPartialModel"><code>AbstractPartialModel</code></a> the grid is  pre-initialised to zero and rules manually populate the dest grid.</p><p>Returns a tuple containing the source and dest arrays for the next iteration.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L55-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.inbounds" href="#Cellular.inbounds"><code>Cellular.inbounds</code></a> â€” <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">inbounds(x, max, overflow)</code></pre><p>Check grid boundaries for a single coordinate and max value or a tuple  of coorinates and max values.</p><p>Returns a tuple containing the coordinate(s) followed by a boolean <code>true</code>  if the cell is in bounds, <code>false</code> if not.</p><p>Overflow of type <a href="index.html#Cellular.Skip"><code>Skip</code></a> returns the coordinate and <code>false</code> to skip  coordinates that overflow outside of the grid.  <a href="index.html#Cellular.Wrap"><code>Wrap</code></a> returns a tuple with the current position or it&#39;s  wrapped equivalent, and <code>true</code> as it is allways in-bounds.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/framework.jl#L113-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cellular.process_image" href="#Cellular.process_image"><code>Cellular.process_image</code></a> â€” <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">process_image(frame, output)</code></pre><p>Converts an array to an image format.</p></div><a class="source-link" target="_blank" href="https://github.com/rafaqz/Cellular.jl/blob/1d1cb4555d01a755f0e674720cc6a57e3769f808/src/output.jl#L169-L172">source</a></section><footer><hr/></footer></article></body></html>
