<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicGrids.jl · DynamicGrids.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DynamicGrids.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DynamicGrids.jl</a><ul class="internal"><li><a class="tocitem" href="#Examples-1"><span>Examples</span></a></li><li><a class="tocitem" href="#Rules-1"><span>Rules</span></a></li><li><a class="tocitem" href="#Neighborhoods-1"><span>Neighborhoods</span></a></li><li><a class="tocitem" href="#Output-1"><span>Output</span></a></li><li><a class="tocitem" href="#Overflow-1"><span>Overflow</span></a></li><li class="toplevel"><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DynamicGrids.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DynamicGrids.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicGrids.jl-1"><a class="docs-heading-anchor" href="#DynamicGrids.jl-1">DynamicGrids.jl</a><a class="docs-heading-anchor-permalink" href="#DynamicGrids.jl-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids" href="#DynamicGrids"><code>DynamicGrids</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>DynamicGrids</strong></p><p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://cesaraustralia.github.io/DynamicGrids.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://travis-ci.org/cesaraustralia/DynamicGrids.jl"><img src="https://travis-ci.org/cesaraustralia/DynamicGrids.jl.svg?branch=master" alt="Build Status"/></a>  <a href="https://coveralls.io/github/cesaraustralia/DynamicGrids.jl?branch=master"><img src="https://coveralls.io/repos/cesaraustralia/DynamicGrids.jl/badge.svg?branch=master&amp;service=github" alt="Coverage Status"/></a>  <a href="http://codecov.io/github/cesaraustralia/DynamicGrids.jl?branch=master"><img src="http://codecov.io/github/cesaraustralia/DynamicGrids.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>DynamicGrids is a generalised framework for building high-performance grid-based spatial models, including celluar automata, but also allowing arbitrary behviours such as long distance jumps and interactions between multiple grids. It is extended by <a href="https://github.com/cesaraustralia/Dispersal.jl">Dispersal.jl</a> for modelling organism dispersal processes.</p><p><img src="https://raw.githubusercontent.com/cesaraustralia/DynamicGrids.jl/media/dispersal_quarantine.gif" alt="Dispersal quarantine"/></p><p><em>A dispersal simulation with quarantine interactions, using Dispersal.jl, custom rules and the  GtkOuput from <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk</a>.  Note that this is indicative of the real-time frame-rate on a laptop.</em></p><p>A DynamicGrids.jl simulation is run with a script like this one running the included game of life model <code>Life()</code>:</p><pre><code class="language-julia">using DynamicGrids, Crayons
init = rand(Bool, 150, 200)
output = REPLOutput(init; fps=30, color=Crayon(foreground=:red, background=:black, bold=true))
ruleset = Ruleset(Life(); init=init)
sim!(output, ruleset; tspan=(1, 200))</code></pre><p><img src="https://github.com/cesaraustralia/DynamicGrids.jl/blob/media/life.gif?raw=true" alt="REPL life"/></p><p><em>A game of life simulation being displayed directly in a terminal.</em></p><p><strong>Concepts</strong></p><p>The framework is highly customisable, but there are some central ideas that define how a simulation works: <em>rules</em> and <em>interactions</em>, <em>init</em> arrays and <em>outputs</em>.</p><p><strong>Rules and Interactions</strong></p><p>Rules hold the parameters for running a simulation. Each rule triggers a specific <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> method that operates on each of the active cells in the grid. Rules come in a number of flavours (outlined in the  <a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Rules-1">docs</a>), which allow assumptions to be made about running them that can greatly improve performance. Rules are joined in a <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> object and run in sequence:</p><pre><code class="language-none">ruleset = Ruleset(Life(2, 3))</code></pre><p>The <a href="@ref"><code>Rulset</code></a> wrapper seems a little redundant here, but multiple models can be combined in a <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a>. Each rule will be run for the whole grid, in sequence, using appropriate optimisations depending on the parent types of each rule:</p><pre><code class="language-julia">ruleset = Ruleset(rule1, rule2)</code></pre><p>For better performance (often ~2x), models included in a <a href="#DynamicGrids.Chain"><code>Chain</code></a> object will be combined into a single model, using only one array read and write. This optimisation is limited to <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>, or a <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a> followed by <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>. If the <code>@inline</code> compiler macro is used on all <a href="#DynamicGrids.applyrule"><code>applyrule</code></a> methods, all rules in a <a href="#DynamicGrids.Chain"><code>Chain</code></a> will be compiled together into a single,  efficient function call.</p><pre><code class="language-julia">ruleset = Ruleset(rule1, Chain(rule2, rule3, rule4))</code></pre><p>A <a href="@ref"><code>MultiRuleset</code></a> holds, as the name suggests, multiple rulesets. These may either run side by side independently (say for live comparative analysis), or interact using <a href="#DynamicGrids.Interaction"><code>Interaction</code></a> rules. An <a href="#DynamicGrids.Interaction"><code>Interaction</code></a> is a rule that operates on multiple grids, linking multiple discrete <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a>s into a larger model, such as this hypothetical spatial predator/prey model:</p><pre><code class="language-julia">MuliRuleset(rules=(predator=predatordispersal, prey=Chain(popgrowth, preydispersal)),
            interactions=(predation,))</code></pre><p><strong>Init</strong></p><p>The <a href="@ref"><code>init</code></a> array may be any <a href="@ref"><code>AbstractArray</code></a>, containing whatever initialisation data is required to start the simulation. The array type, size and element type of the <a href="@ref"><code>init</code></a> array determine the types used in the simulation, as well as providing the initial conditions:</p><pre><code class="language-juli">init = rand(Float32, 100, 100)</code></pre><p>An <a href="@ref"><code>init</code></a> array can be attached to a <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a>: </p><pre><code class="language-none">ruleset = Ruleset(Life(); init=init)</code></pre><p>or passed into a simulation, where it will take preference over the <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> init:</p><pre><code class="language-none">sim!(output, rulset; init=init)</code></pre><p>For <a href="@ref"><code>MultiRuleset</code></a>, <a href="@ref"><code>init</code></a> is a <a href="@ref"><code>NamedTuple</code></a> of equal-sized arrays matching the names given to each <a href="#DynamicGrids.Ruleset"><code>Ruleset</code></a> :</p><pre><code class="language-julia">init = (predator=rand(100, 100), prey=(rand(100, 100))</code></pre><p>Handling and passing of the correct arrays is automated by DynamicGrids.jl. <a href="#DynamicGrids.Interaction"><code>Interaction</code></a> rules must specify which grids they require in what order. </p><p>Passing spatial <a href="@ref"><code>init</code></a> arrays from <a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a>  will propagate through the model to give spatially explicit output. This will plot  correctly as a map using <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>,  to which shape files and observation points can be easily added.</p><p><strong>Output</strong></p><p><a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Output-1">Outputs</a> are ways of storing or viewing a simulation. They can be used interchangeably depending on your needs: <a href="#DynamicGrids.ArrayOutput"><code>ArrayOutput</code></a> is a simple storage structure for high performance-simulations. As with most outputs, it is initialised with the <a href="@ref"><code>init</code></a> array, but in this case it also requires the number of simulation frames to preallocate before the simulation runs.</p><pre><code class="language-julia">output = ArrayOutput(init, 10)</code></pre><p>The <a href="#DynamicGrids.REPLOutput"><code>REPLOutput</code></a> shown above is an inbuilt <a href="#DynamicGrids.GraphicOutput"><code>GraphicOutput</code></a> that can be useful for checking a simulation when working in a terminal or over ssh:</p><pre><code class="language-julia">output = REPLOutput(init)</code></pre><p><a href="#DynamicGrids.ImageOutput"><code>ImageOutput</code></a> is the most complex class of outputs, allowing full color visual simulations using COlorSchemes.jl. It can also display interactions using color  composites or layouts, as shown above in the quarantine simulation.</p><p><a href="https://github.com/cesaraustralia/DynamicGridsInteract.jl">DynamicGridsInteract.jl</a> provides simulation interfaces for use in Juno, Jupyter, web pages or electron apps, with live interactive control over parameters. <a href="https://github.com/cesaraustralia/DynamicGridsGtk.jl">DynamicGridsGtk.jl</a> is a simple graphical output for Gtk. These packages are kept separate to avoid dependencies when being used in non-graphical simulations. </p><p>Outputs are also easy to write, and high performance or applications may benefit from writing a custom output to reduce memory use, such as running a loss function on the fly instead of storing the array. Performance of DynamicGrids.jl is dominated by cache interactions, and reducing memory use has significant positive effects. Custom  <a href="https://cesaraustralia.github.io/DynamicGrids.jl/stable/#Frame-processors-1">frame processors</a> can also be written, which can help developing specialised visualisations.</p><p><strong>Example</strong></p><p>This example implements a very simple forest fire model:</p><pre><code class="language-julia">using DynamicGrids, DynamicGridsGtk, ColorSchemes, Colors

const DEAD = 1
const ALIVE = 2
const BURNING = 3

# Define the Rule struct
struct ForestFire{N,PC,PR} &lt;: NeighborhoodRule
    neighborhood::N
    prob_combustion::PC
    prob_regrowth::PR
end
ForestFire(; neighborhood=RadialNeighborhood{1}(), prob_combustion=0.0001, prob_regrowth=0.01) =
    ForestFire(neighborhood, prob_combustion, prob_regrowth)

# Define an [`applyrule`](@ref) method to be broadcasted over the grid for the [`ForestFire`](@ref) rule
@inline DynamicGrids.applyrule(rule::ForestFire, data, state::Integer, index, hoodbuffer) =
    if state == ALIVE
        if BURNING in DynamicGrids.neighbors(rule, hoodbuffer)
            BURNING
        else
            rand() &lt;= rule.prob_combustion ? BURNING : ALIVE
        end
    elseif state in BURNING
        DEAD
    else
        rand() &lt;= rule.prob_regrowth ? ALIVE : DEAD
    end

# Set up the init array, ruleset and output (using a Gtk window)
init = fill(ALIVE, 400, 400)
ruleset = Ruleset(ForestFire(); init=init)
processor = ColorProcessor(scheme=ColorSchemes.rainbow, zerocolor=RGB24(0.0))
output = GtkOutput(init; fps=25, minval=DEAD, maxval=BURNING, processor=processor)

# Run the simulation
sim!(output, ruleset; tspan=(1, 200))

# Save the output as a gif
savegif(&quot;forestfire.gif&quot;, output)

</code></pre><p><img src="https://user-images.githubusercontent.com/2534009/72052469-5450c580-3319-11ea-8948-5196d1c6fd33.gif" alt="forestfire"/></p><p>We could also use a &quot;windy&quot; custom neighborhood:</p><pre><code class="language-none">windyhood = CustomNeighborhood((1,1), (1,2), (1,3), (2,1), (3,1))
ruleset = Ruleset(ForestFire(; neighborhood=windyhood); init=init)
sim!(output, ruleset; tspan=(1, 200))
savegif(&quot;windy_forestfire.gif&quot;, output)</code></pre><p><img src="https://user-images.githubusercontent.com/2534009/72198637-a95d1a80-3484-11ea-8b77-25a4a94b3943.gif" alt="windy_forestfire"/></p><p>Timing the simulation for 200 steps, the performance is quite good:</p><pre><code class="language-none">output = ArrayOutput(init, 200)
@time sim!(output, ruleset; tspan=(1, 200))
 1.384755 seconds (640 allocations: 2.569 MiB)

# To save a gif of the ArrayOutput we need to pass in a processor and the min and max
# values used in the simulation:

savegif(&quot;forestfire.gif&quot;, output; minval=DEAD, maxval=BURNING, processor=processor)</code></pre><p><strong>Alternatives</strong></p><p><a href="https://github.com/JuliaDynamics/Agents.jl">Agents.jl</a> can also do cellular-automata style simulations. The design of Agents.jl is to iterate over a list of agents, instead of broadcasting over an array of cells. This approach is well suited to when you need to track the movement and details about individual agents throughout the simulation. </p><p>However, for simple grid models where you don&#39;t need to track individuals, like the forest fire model above, DynamicGrids.jl is two orders of magnitude faster than Agents.jl, and provides better visualisation tools. If you are doing grid-based simulation and you don&#39;t need to track individual agents, DynamicGrids.jl is probably the best tool. For other use cases, try Agents.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/DynamicGrids.jl#L3-L244">source</a></section></article><h2 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h2><p>While this package isn&#39;t designed or optimised specifically to run the game of life, it&#39;s a simple example of what this package can do. This example runs a game of life and displays it in a REPLOutput.</p><pre><code class="language-julia">using DynamicGrids

# Build a random starting grid
init = round.(Int8, max.(0.0, rand(-2.0:0.1:1.0, 70,70)))

# Use the default game of life model
model = Ruleset(Life())

# Use an output that shows the cellular automata as blocks in the REPL
output = REPLOutput(init; fps=5)

sim!(output, model; init=init, tspan=(1, 50))</code></pre><pre><code class="language-none">1-element REPLOutput{Array{Array{Int8,2},1},Int64,Float64,Float64,Int64,Symbol,Float64,Block}:
 Int8[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]</code></pre><p>More life-like examples:</p><pre><code class="language-julia"># Morley
sim!(output, Ruleset(Life(b=[3,6,8], s=[2,4,5]); init=init))

# 2x2
sim!(output, Ruleset(Life(b=[3,6], s=[1,2,5]); init=init))

# Dimoeba
init1 = round.(Int8, max.(0.0, rand(70,70)))
sim!(output, Ruleset(Life(b=[3,5,6,7,8], s=[5,6,7,8]); init=init1))

## No death
sim!(output, Ruleset(Life(b=[3], s=[0,1,2,3,4,5,6,7,8]); init))

## 34 life
sim!(output, Ruleset(Life(b=[3,4], s=[3,4])); init=init, fps=10)

# Replicator
init2 = round.(Int8, max.(0.0, rand(70,70)))
init2[:, 1:30] .= 0
init2[21:50, :] .= 0
sim!(output, Ruleset(Life(b=[1,3,5,7], s=[1,3,5,7])); init=init2)</code></pre><h2 id="Rules-1"><a class="docs-heading-anchor" href="#Rules-1">Rules</a><a class="docs-heading-anchor-permalink" href="#Rules-1" title="Permalink"></a></h2><p>Rules define simulation behaviour. They hold data relevant to the simulation, and trigger dispatch of particular <a href="@ref"><code>applyrule</code></a> or <a href="@ref"><code>applyrule!</code></a> methods. Rules can be chained together arbitrarily to make composite simulations.</p><h3 id="Types-and-Constructors-1"><a class="docs-heading-anchor" href="#Types-and-Constructors-1">Types and Constructors</a><a class="docs-heading-anchor-permalink" href="#Types-and-Constructors-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Ruleset" href="#DynamicGrids.Ruleset"><code>DynamicGrids.Ruleset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ruleset(rules...; init=nothing, overflow=RemoveOverflow(), cellsize=1, timestep=1)</code></pre><p>A container for holding a sequence of <code>Rule</code>, an <code>init</code> array and other simulaiton details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Rule" href="#DynamicGrids.Rule"><code>DynamicGrids.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Rule</code></pre><p>A rule contains all the information required to run a rule in a cellular simulation, given an initial array. Rules can be chained together sequentially.</p><p>The output of the rule for an Rule is allways written to the current cell in the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/rules.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CellRule" href="#DynamicGrids.CellRule"><code>DynamicGrids.CellRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type CellRule &lt;: Rule</code></pre><p>A Rule that only writes and accesses a single cell: its return value is the new value of the cell. This limitation can be useful for performance optimisations.</p><p>Accessing the <code>data.source</code> and <code>data.dest</code> arrays directly is not guaranteed to have correct results, and should not be done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/rules.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.NeighborhoodRule" href="#DynamicGrids.NeighborhoodRule"><code>DynamicGrids.NeighborhoodRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type NeighborhoodRule &lt;: Rule</code></pre><p>A Rule That only accesses a neighborhood, defined by its radius distance from the current cell.</p><p>For each cell a neighborhood buffer will be populated containing the neighborhood cells, and passed to <code>applyrule</code> as an extra argmuent: <code>applyrule(rule, data, state, index, buffer)</code>. This allows memory optimisations and the use of BLAS routines on the neighborhood buffer for <a href="#DynamicGrids.RadialNeighborhood"><code>RadialNeighborhood</code></a>. It also means that and no bounds checking is required in neighborhood code, a major performance gain.</p><p><code>NeighborhoodRule</code> should read only from the state variable and the neighborhood buffer array. The return value is written to the central cell for the next grid frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/rules.jl#L37-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.PartialRule" href="#DynamicGrids.PartialRule"><code>DynamicGrids.PartialRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type PartialRule &lt;: Rule</code></pre><p>PartialRule is for rules that manually write to whichever cells of the grid that they choose, instead of updating every cell with their output.</p><p>Updates to the destination array (<code>dest(data)</code>) must be performed manually, while the source array can be accessed with <code>source(data)</code>.</p><p>The dest array is copied from the source prior to running the <code>applyrule!</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/rules.jl#L26-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.PartialNeighborhoodRule" href="#DynamicGrids.PartialNeighborhoodRule"><code>DynamicGrids.PartialNeighborhoodRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type PartialNeighborhoodRule &lt;: PartialRule</code></pre><p>A Rule that only writes to its neighborhood, defined by its radius distance from the current point. TODO: should this exist?</p><p>Custom PartialNeighborhood rules must return their radius with a <code>radius()</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/rules.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Life" href="#DynamicGrids.Life"><code>DynamicGrids.Life</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rule for game-of-life style cellular automata. This is a demonstration of  Cellular Automata more than a seriously optimised game of life rule.</p><p>Cells becomes active if it is empty and the number of neightbors is a number in the b array, and remains active the cell is active and the number of neightbors is in the s array.</p><p>Returns: boolean</p><p><strong>Examples (gleaned from CellularAutomata.jl)</strong></p><pre><code class="language-julia"># Life. 
init = round.(Int64, max.(0.0, rand(-3.0:0.1:1.0, 300,300)))
output = REPLOutput(init; fps=10, color=:red)
sim!(output, rule, init; tspan=(1, 1000)

# Dimoeba
init = rand(0:1, 400, 300)
init[:, 100:200] .= 0
output = REPLOutput{:braile}(init; fps=25, color=:blue)
sim!(output, Ruleset(Life(b=(3,5,6,7,8), s=(5,6,7,8))), init; tspan=(1, 1000))

# Replicator
init = fill(1, 300,300)
init[:, 100:200] .= 0
init[10, :] .= 0
output = REPLOutput(init; fps=60, color=:yellow)
sim!(output, Ruleset(Life(b=(1,3,5,7), s=(1,3,5,7))), init; tspan=(1, 1000))</code></pre><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th><th style="text-align: right">Limits</th></tr><tr><td style="text-align: right">neighborhood</td><td style="text-align: right">Any Neighborhood</td><td style="text-align: right">RadialNeighborhood{1}()</td><td style="text-align: right">nothing</td></tr><tr><td style="text-align: right">b</td><td style="text-align: right">Array, Tuple or Iterable of integers to match neighbors when cell is empty</td><td style="text-align: right">(3, 3)</td><td style="text-align: right">(0, 8)</td></tr><tr><td style="text-align: right">s</td><td style="text-align: right">Array, Tuple or Iterable of integers to match neighbors cell is full</td><td style="text-align: right">(2, 3)</td><td style="text-align: right">(0, 8)</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Chain" href="#DynamicGrids.Chain"><code>DynamicGrids.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Chain{T&lt;:Union{Tuple{}, Tuple{#s12,Vararg{CellRule,N} where N} where #s12&lt;:Union{CellRule, NeighborhoodRule}}} &lt;: Rule</code></pre><p>Chains allow chaining rules together to be completed in a single processing step without intermediate writes, and potentially compiled together into a single function call. These can either be all CellRule or NeighborhoodRule followed by CellRule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/chain.jl#L1-L5">source</a></section></article><p><code>Interaction</code> rules specify interactions between multiple dynamic grids.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Interaction" href="#DynamicGrids.Interaction"><code>DynamicGrids.Interaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Interaction &lt;: Rule</code></pre><p>Rules that involved the interaction between two grids</p><p>Applied using <a href="@ref">`applyinteraction</a> and <a href="@ref">`applyinteraction!</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interactions.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.NeighborhoodInteraction" href="#DynamicGrids.NeighborhoodInteraction"><code>DynamicGrids.NeighborhoodInteraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type NeighborhoodInteraction &lt;: Interaction{Keys}</code></pre><p>Interactions that use a neighborhood and write to the current cell, analagous to <a href="#DynamicGrids.NeighborhoodRule"><code>NeighborhoodRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interactions.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CellInteraction" href="#DynamicGrids.CellInteraction"><code>DynamicGrids.CellInteraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type CellInteraction &lt;: Interaction{Keys}</code></pre><p>Cell by cell interaction, analogous to <a href="#DynamicGrids.CellRule"><code>CellRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interactions.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.PartialInteraction" href="#DynamicGrids.PartialInteraction"><code>DynamicGrids.PartialInteraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type PartialInteraction &lt;: Interaction{Keys}</code></pre><p>Rules that conditionally apply to particular cells, but may not write to every cell in the grid. Analogous to <a href="#DynamicGrids.PartialRule"><code>PartialRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interactions.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.PartialNeighborhoodInteraction" href="#DynamicGrids.PartialNeighborhoodInteraction"><code>DynamicGrids.PartialNeighborhoodInteraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type PartialNeighborhoodInteraction &lt;: PartialInteraction{Keys}</code></pre><p>Interactions that write to a neighborhood, analogous to <a href="#DynamicGrids.PartialNeighborhoodRule"><code>PartialNeighborhoodRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interactions.jl#L55-L57">source</a></section></article><h2 id="Neighborhoods-1"><a class="docs-heading-anchor" href="#Neighborhoods-1">Neighborhoods</a><a class="docs-heading-anchor-permalink" href="#Neighborhoods-1" title="Permalink"></a></h2><p>Neighborhoods define a pattern of cells surrounding the current cell,  and how they are combined to update the value of the current cell.</p><h3 id="Types-and-Constructors-2"><a class="docs-heading-anchor" href="#Types-and-Constructors-2">Types and Constructors</a><a class="docs-heading-anchor-permalink" href="#Types-and-Constructors-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Neighborhood" href="#DynamicGrids.Neighborhood"><code>DynamicGrids.Neighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Neighborhood</code></pre><p>Neighborhoods define how surrounding cells are related to the current cell. The <code>neighbors</code> function returns the sum of surrounding cells, as defined by the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/neighborhoods.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractRadialNeighborhood" href="#DynamicGrids.AbstractRadialNeighborhood"><code>DynamicGrids.AbstractRadialNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractRadialNeighborhood &lt;: Neighborhood{R}</code></pre><p>A Moore-style neighborhood where a square are with a center radius <code>(D - 1) / 2</code> where D is the diameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/neighborhoods.jl#L11-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RadialNeighborhood" href="#DynamicGrids.RadialNeighborhood"><code>DynamicGrids.RadialNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RadialNeighborhood{R} &lt;: AbstractRadialNeighborhood{R}</code></pre><p>Radial neighborhoods calculate the surrounding neighborood from the radius around the central cell. The central cell is ommitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/neighborhoods.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.AbstractCustomNeighborhood" href="#DynamicGrids.AbstractCustomNeighborhood"><code>DynamicGrids.AbstractCustomNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractCustomNeighborhood &lt;: Neighborhood{R}</code></pre><p>Custom neighborhoods are tuples of custom coordinates (also tuples) specified in relation to the central point of the current cell. They can be any arbitrary shape or size, but should be listed in column-major order for performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/neighborhoods.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.CustomNeighborhood" href="#DynamicGrids.CustomNeighborhood"><code>DynamicGrids.CustomNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Allows completely arbitrary neighborhood shapes by specifying each coordinate specifically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.LayeredCustomNeighborhood" href="#DynamicGrids.LayeredCustomNeighborhood"><code>DynamicGrids.LayeredCustomNeighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sets of custom neighborhoods that can have separate rules for each set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L2">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>neighbors</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>sumneighbors</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>mapsetneighbor!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>setneighbor!</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Output-1"><a class="docs-heading-anchor" href="#Output-1">Output</a><a class="docs-heading-anchor-permalink" href="#Output-1" title="Permalink"></a></h2><h3 id="Output-Types-and-Constructors-1"><a class="docs-heading-anchor" href="#Output-Types-and-Constructors-1">Output Types and Constructors</a><a class="docs-heading-anchor-permalink" href="#Output-Types-and-Constructors-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Output" href="#DynamicGrids.Output"><code>DynamicGrids.Output</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Output &lt;: AbstractArray{T,1}</code></pre><p>All outputs must inherit from Output.</p><p>Simulation outputs are decoupled from simulation behaviour and in many cases can be used interchangeably.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/output.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ArrayOutput" href="#DynamicGrids.ArrayOutput"><code>DynamicGrids.ArrayOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A simple output that stores each step of the simulation in a vector of arrays.</p><p><strong>Arguments:</strong></p><ul><li><code>frames</code>: Single init array or vector of arrays</li><li><code>length</code>: The length of the output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.GraphicOutput" href="#DynamicGrids.GraphicOutput"><code>DynamicGrids.GraphicOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type GraphicOutput &lt;: Output{T}</code></pre><p>Outputs that display the simulation frames live.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/graphic.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.REPLOutput" href="#DynamicGrids.REPLOutput"><code>DynamicGrids.REPLOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An output that is displayed directly in the REPL. It can either store or discard simulation frames.</p><p><strong>Arguments:</strong></p><ul><li><code>frames</code>: Single init array or vector of arrays</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>fps::Real</code>: frames per second to run at</li><li><code>showfps::Real</code>: maximum displayed frames per second</li><li><code>store::Bool</code>: store frames or not</li><li><code>color</code>: a color from Crayons.jl</li><li><code>cutoff::Real</code>: the cutoff point to display a full or empty cell. Default is <code>0.5</code></li><li><code>style::CharStyle</code>: <code>Block()</code> or <code>Braile()</code> style printing. <code>Braile</code> uses 1/4 the screen space.</li></ul><pre><code class="language-julia">REPLOutput(init)</code></pre><p>The default option is <code>:block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ImageOutput" href="#DynamicGrids.ImageOutput"><code>DynamicGrids.ImageOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ImageOutput &lt;: GraphicOutput{T}</code></pre><p>Graphic outputs that displays an output frame as an RGB24 images.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/image.jl#L1-L3">source</a></section></article><p>Dynamic grids uses <a href="https://github.com/rafaqz/Mixers.jl">Mixers.jl</a> mixins to simplify specifying custom outputs with the required fields.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.@Output" href="#DynamicGrids.@Output"><code>DynamicGrids.@Output</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Mixin of basic fields for all outputs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/output.jl#L32-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.@Graphic" href="#DynamicGrids.@Graphic"><code>DynamicGrids.@Graphic</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Mixin for graphic output fields</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/graphic.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.@Image" href="#DynamicGrids.@Image"><code>DynamicGrids.@Image</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Mixin for outputs that output images and can use an image processor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/image.jl#L12-L14">source</a></section></article><h3 id="Grid-processors-1"><a class="docs-heading-anchor" href="#Grid-processors-1">Grid processors</a><a class="docs-heading-anchor-permalink" href="#Grid-processors-1" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FrameProcessor</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SingleFrameProcessor</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ColorProcessor" href="#DynamicGrids.ColorProcessor"><code>DynamicGrids.ColorProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>&quot;     ColorProcessor(; scheme=Greyscale(), zerocolor=nothing, maskcolor=nothing)</p><p>Converts output grids to a colorsheme.</p><p><strong>Arguments / Keyword Arguments</strong></p><ul><li><code>scheme</code>: a ColorSchemes.jl colorscheme.</li><li><code>zerocolor</code>: an <code>RGB24</code> color to use when values are zero, or <code>nothing</code> to ignore.</li><li><code>maskcolor</code>: an <code>RGB24</code> color to use when cells are masked, or <code>nothing</code> to ignore.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L10">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MultiFrameProcessor</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ThreeColorProcessor" href="#DynamicGrids.ThreeColorProcessor"><code>DynamicGrids.ThreeColorProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ThreeColorProcessor(; colors=(Red(), Green(), Blue()), zerocolor=nothing, maskcolor=nothing)</code></pre><p>Assigns <code>Red()</code>, <code>Blue()</code>, <code>Green()</code> or <code>nothing</code> to any number of dynamic grids in any order. Duplicate colors will be summed. The final color sums are combined into a composite color image for display.</p><p><strong>Arguments / Keyword Arguments</strong></p><ul><li><code>colors</code>: a tuple or <code>Red()</code>, <code>Green()</code>, <code>Blue()</code>, or <code>nothing</code> matching the number of grids.</li><li><code>zerocolor</code>: an <code>RGB24</code> color to use when values are zero, or <code>nothing</code> to ignore.</li><li><code>maskcolor</code>: an <code>RGB24</code> color to use when cells are masked, or <code>nothing</code> to ignore.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.LayoutProcessor" href="#DynamicGrids.LayoutProcessor"><code>DynamicGrids.LayoutProcessor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LayoutProcessor(layout::Array, processors)     LayoutProcessor(reshape(layout, length(layout), 1), processors)</p><p><strong>Arguments / Keyword arguments</strong></p><ul><li><code>layout</code>: A Vector or Matrix containing the keyes or numbers of grids in the locations to display them. <code>nothing</code>, <code>missing</code> or <code>0</code> values will be skipped.</li><li><code>processors</code>: tuple of SingleGridProcessor, one for each grid in the simulation. Can be <code>nothing</code> for unused grids.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Greyscale" href="#DynamicGrids.Greyscale"><code>DynamicGrids.Greyscale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Greyscale{M1, M2}</code></pre><p>Default colorscheme. Better performance than using a Colorschemes.jl scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/image.jl#L35-L37">source</a></section></article><h3 id="Gifs-1"><a class="docs-heading-anchor" href="#Gifs-1">Gifs</a><a class="docs-heading-anchor-permalink" href="#Gifs-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.savegif" href="#DynamicGrids.savegif"><code>DynamicGrids.savegif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">savegif(filename::String, o::Output, ruleset; [processor=processor(o)], [kwargs...])</code></pre><p>Write the output array to a gif. You must pass a processor keyword argument for any <code>Output</code> objects not in <code>ImageOutput</code> (which allready have a processor attached).</p><p>Saving very large gifs may trigger a bug in Imagemagick.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/image.jl#L250-L257">source</a></section></article><h3 id="Internal-data-handling-1"><a class="docs-heading-anchor" href="#Internal-data-handling-1">Internal data handling</a><a class="docs-heading-anchor-permalink" href="#Internal-data-handling-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.SimData" href="#DynamicGrids.SimData"><code>DynamicGrids.SimData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simulation data and storage is passed to rules for each timestep </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/simulationdata.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.MultiSimData" href="#DynamicGrids.MultiSimData"><code>DynamicGrids.MultiSimData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MultiSimData{I, D&lt;:NamedTuple, Ru} &lt;: AbstractSimData</code></pre><p>MultipleSimData is used for MultiRuleset models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/simulationdata.jl#L104-L106">source</a></section></article><h2 id="Overflow-1"><a class="docs-heading-anchor" href="#Overflow-1">Overflow</a><a class="docs-heading-anchor-permalink" href="#Overflow-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.Overflow" href="#DynamicGrids.Overflow"><code>DynamicGrids.Overflow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Overflow</code></pre><p>Singleton types for choosing the grid overflow rule used in <a href="#DynamicGrids.inbounds-Tuple{Tuple,Tuple,Any}"><code>inbounds</code></a>. These determine what is done when a neighborhood or jump extends outside of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/rulesets.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.WrapOverflow" href="#DynamicGrids.WrapOverflow"><code>DynamicGrids.WrapOverflow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct WrapOverflow &lt;: Overflow</code></pre><p>Wrap cords that overflow boundaries back to the opposite side</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/rulesets.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.RemoveOverflow" href="#DynamicGrids.RemoveOverflow"><code>DynamicGrids.RemoveOverflow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RemoveOverflow &lt;: Overflow</code></pre><p>Remove coords that overflow boundaries</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/rulesets.jl#L11">source</a></section></article><h1 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.VonNeumannNeighborhood-Tuple{}" href="#DynamicGrids.VonNeumannNeighborhood-Tuple{}"><code>DynamicGrids.VonNeumannNeighborhood</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A convenience wrapper to build a VonNeumann neighborhoods as a <code>CustomNeighborhood</code>.</p><p><strong>TODO: variable radius</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/neighborhoods.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.resume!-Tuple{Any,Any}" href="#DynamicGrids.resume!-Tuple{Any,Any}"><code>DynamicGrids.resume!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resume!(output, ruleset; tadd=100, kwargs...)</code></pre><p>Restart the simulation where you stopped last time. For arguments see <a href="#DynamicGrids.sim!-Tuple{Any,Any}"><code>sim!</code></a>. The keyword arg <code>tadd</code> indicates the number of grid frames to add, and of course an init array will not be accepted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/framework.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.savegif" href="#DynamicGrids.savegif"><code>DynamicGrids.savegif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">savegif(filename::String, o::Output, ruleset; [processor=processor(o)], [kwargs...])</code></pre><p>Write the output array to a gif. You must pass a processor keyword argument for any <code>Output</code> objects not in <code>ImageOutput</code> (which allready have a processor attached).</p><p>Saving very large gifs may trigger a bug in Imagemagick.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/image.jl#L250-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sim!-Tuple{Any,Any}" href="#DynamicGrids.sim!-Tuple{Any,Any}"><code>DynamicGrids.sim!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sim!(output, ruleset; init=nothing, tstpan=(1, length(output)),      fps=fps(output), data=nothing, nreplicates=nothing)</p><p>Runs the whole simulation, passing the destination aray to the passed in output for each time-step.</p><p><strong>Arguments</strong></p><ul><li><code>output</code>: An <a href="#Output-1">Output</a> to store grids or display them on the screen.</li><li><code>ruleset</code>: A Rule() containing one ore more <a href="#DynamicGrids.Rule"><code>Rule</code></a>. These will each be run in sequence.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>init</code>: the initialisation array. If <code>nothing</code>, the Ruleset must contain an <code>init</code> array.</li><li><code>tspan</code>: the timespan simulaiton will run for.</li><li><code>fps</code>: the frames per second to display. Will be taken from the output if not passed in.</li><li><code>nreplicates</code>: the number of replicates to combine in stochastic simulations</li><li><code>data</code>: a SimData object. Can reduce allocations when that is important.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/framework.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.addpadding-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Any}} where N where T" href="#DynamicGrids.addpadding-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Any}} where N where T"><code>DynamicGrids.addpadding</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the maximum radius required by all rules Add padding around the original init array, offset into the negative So that the first real cell is still 1, 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/simulationdata.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyinteraction" href="#DynamicGrids.applyinteraction"><code>DynamicGrids.applyinteraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyinteraction(interacttion::PartialRule, data, state, index)</code></pre><p>Applay an interation that returns a tuple of values.</p><p><strong>Arguments:</strong></p><p>see <a href="#DynamicGrids.applyrule"><code>applyrule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyinteraction!" href="#DynamicGrids.applyinteraction!"><code>DynamicGrids.applyinteraction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyinteraction!(interacttion::PartialRule, data, state, index)</code></pre><p>Applay an interation that manually writes to the passed in dest arrays.</p><p><strong>Arguments:</strong></p><p>see <a href="#DynamicGrids.applyrule"><code>applyrule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule" href="#DynamicGrids.applyrule"><code>DynamicGrids.applyrule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyrule(rule::Rule, data, state, index, [buffer])</code></pre><p>Updates cell values based on their current state and the state of other cells as defined in the Rule.</p><p><strong>Arguments:</strong></p><ul><li><code>rule</code> : <a href="#DynamicGrids.Rule"><code>Rule</code></a></li><li><code>data</code> : <a href="#DynamicGrids.SimData"><code>SimData</code></a></li><li><code>state</code>: the value of the current cell</li><li><code>index</code>: a (row, column) tuple of Int for the current cell coordinates - <code>t</code>: the current time step</li><li><code>buffer</code>: a neighborhood burrer array passed to [<code>NeighborhoodRule</code>].</li></ul><p>Returns a value to be written to the current cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule!" href="#DynamicGrids.applyrule!"><code>DynamicGrids.applyrule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">applyrule!(rule::PartialRule, data, state, index)</code></pre><p>A rule that manually writes to the dest array, used in rules inheriting from <a href="#DynamicGrids.PartialRule"><code>PartialRule</code></a>.</p><p><strong>Arguments:</strong></p><p>see <a href="#DynamicGrids.applyrule"><code>applyrule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.applyrule-Tuple{Chain{#s25} where #s25&lt;:(Tuple{#s24,Vararg{Any,N} where N} where #s24&lt;:NeighborhoodRule),Any,Any,Any,Any}" href="#DynamicGrids.applyrule-Tuple{Chain{#s25} where #s25&lt;:(Tuple{#s24,Vararg{Any,N} where N} where #s24&lt;:NeighborhoodRule),Any,Any,Any,Any}"><code>DynamicGrids.applyrule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">applyrule(rules::Chain, data, state, (i, j))</code></pre><p>Chained rules. If a <code>Chain</code> of rules is passed to applyrule, run them sequentially for each  cell.  This can have much beter performance as no writes occur between rules, and they are essentially compiled together into compound rules. This gives correct results only for CellRule, or for a single NeighborhoodRule followed by CellRule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/maprules.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.currenttimestep-Tuple{AbstractSimData}" href="#DynamicGrids.currenttimestep-Tuple{AbstractSimData}"><code>DynamicGrids.currenttimestep</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the actual current timestep, ie. not variable periods like Month</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/simulationdata.jl#L61-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.grid2image" href="#DynamicGrids.grid2image"><code>DynamicGrids.grid2image</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Convert a grid or named tuple of grids to an RGB24 image, using a GridProcessor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/image.jl#L72-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.handleoverflow!-Tuple{DynamicGrids.SingleSimData,Integer}" href="#DynamicGrids.handleoverflow!-Tuple{DynamicGrids.SingleSimData,Integer}"><code>DynamicGrids.handleoverflow!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wrap overflow where required. This optimisation allows us to ignore bounds checks on neighborhoods and still use a wraparound grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/maprules.jl#L176-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.hoodsize-Tuple{Neighborhood}" href="#DynamicGrids.hoodsize-Tuple{Neighborhood}"><code>DynamicGrids.hoodsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hoodsize(radius)</code></pre><p>Get the size of a neighborhood dimension from its radius,  which is always 2r + 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/utils.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.inbounds-Tuple{Tuple,Tuple,Any}" href="#DynamicGrids.inbounds-Tuple{Tuple,Tuple,Any}"><code>DynamicGrids.inbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inbounds(x, max, overflow)</code></pre><p>Check grid boundaries for a single coordinate and max value or a tuple of coorinates and max values.</p><p>Returns a tuple containing the coordinate(s) followed by a boolean <code>true</code> if the cell is in bounds, <code>false</code> if not.</p><p>Overflow of type <a href="#DynamicGrids.RemoveOverflow"><code>RemoveOverflow</code></a> returns the coordinate and <code>false</code> to skip coordinates that overflow outside of the grid. <a href="#DynamicGrids.WrapOverflow"><code>WrapOverflow</code></a> returns a tuple with the current position or it&#39;s wrapped equivalent, and <code>true</code> as it is allways in-bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/utils.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.initframes!-Tuple{GraphicOutput,Any}" href="#DynamicGrids.initframes!-Tuple{GraphicOutput,Any}"><code>DynamicGrids.initframes!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Grids are deleted and reallocated during the simulation, which this allows runs of any length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/graphic.jl#L42-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.initgrids!-Tuple{Output,Any}" href="#DynamicGrids.initgrids!-Tuple{Output,Any}"><code>DynamicGrids.initgrids!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Grids are preallocated and reused.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/outputs/output.jl#L112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.maprule!-Tuple{AbstractSimData,Rule}" href="#DynamicGrids.maprule!-Tuple{AbstractSimData,Rule}"><code>DynamicGrids.maprule!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply the rule for each cell in the grid, using optimisations allowed for the supertype of the rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/maprules.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.maprule!-Union{Tuple{T}, Tuple{SingleSimData{T,2,I} where I,Union{NeighborhoodRule, Chain{#s13} where #s13&lt;:Tuple{NeighborhoodRule,Vararg{Any,N} where N}},Vararg{Any,N} where N}} where T" href="#DynamicGrids.maprule!-Union{Tuple{T}, Tuple{SingleSimData{T,2,I} where I,Union{NeighborhoodRule, Chain{#s13} where #s13&lt;:Tuple{NeighborhoodRule,Vararg{Any,N} where N}},Vararg{Any,N} where N}} where T"><code>DynamicGrids.maprule!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Run the rule for all cells, writing the result to the dest array The neighborhood is copied to the rules neighborhood buffer array for performance</p><p><strong>TODO test 1d</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/maprules.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.mapsetneighbor!" href="#DynamicGrids.mapsetneighbor!"><code>DynamicGrids.mapsetneighbor!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapsetneighbor!(data, hood, rule, state, index)</code></pre><p>Run <code>setneighbors</code> over all cells in the neighborhood and sums its return values. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.neighbors" href="#DynamicGrids.neighbors"><code>DynamicGrids.neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><p>neighbors(hood::Neighborhood, hoodbuffer)</p><p>Returns an iteraterable over all cells in the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.precalcrule!" href="#DynamicGrids.precalcrule!"><code>DynamicGrids.precalcrule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precalcrule!(rule, data)</code></pre><p>Run any precalculations needed to run a rule for a particular frame.</p><p>It may be better to do this in a functional way with an external precalc object passed into a rule via the <code>data</code> object, but it&#39;s done statefully for now for simplicity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.precalcrules-Tuple{Any,Any}" href="#DynamicGrids.precalcrules-Tuple{Any,Any}"><code>DynamicGrids.precalcrules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">precalcrules(rule, data) = rule</code></pre><p>Rule precalculation. This is a functional approach rebuilding rules recursively. @set from Setfield.jl helps in specific rule implementations.</p><p>The default is to return the existing rule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/framework.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.radius" href="#DynamicGrids.radius"><code>DynamicGrids.radius</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the radius of a rule or ruleset if it has one, otherwise zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.radius-Tuple{MultiRuleset}" href="#DynamicGrids.radius-Tuple{MultiRuleset}"><code>DynamicGrids.radius</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the largest radius present in the passed in rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/neighborhoods.jl#L116-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.ruletypes-Tuple{Ruleset}" href="#DynamicGrids.ruletypes-Tuple{Ruleset}"><code>DynamicGrids.ruletypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a tuple of the base types of the rules in the ruleset</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/utils.jl#L45-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.runsim!-Tuple{Any,Vararg{Any,N} where N}" href="#DynamicGrids.runsim!-Tuple{Any,Vararg{Any,N} where N}"><code>DynamicGrids.runsim!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>run the simulation either directly or asynchronously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/framework.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sequencerules!-Tuple{AbstractArray{#s23,1} where #s23&lt;:AbstractSimData,Any}" href="#DynamicGrids.sequencerules!-Tuple{AbstractArray{#s23,1} where #s23&lt;:AbstractSimData,Any}"><code>DynamicGrids.sequencerules!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Threaded replicate simulations. If <code>nreplicates</code> is set the data object will be a vector of replicate data, so we loop over it with threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/sequencerules.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sequencerules!-Tuple{SimData}" href="#DynamicGrids.sequencerules!-Tuple{SimData}"><code>DynamicGrids.sequencerules!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Iterate over all rules recursively, swapping source and dest arrays after each rule or interaction is run.</p><p>Returns a data object with source and dest arrays ready for the next rule  in the sequence, or the next timestep.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/sequencerules.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.setneighbor!" href="#DynamicGrids.setneighbor!"><code>DynamicGrids.setneighbor!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Set value of a cell in the neighborhood. Usually called in <code>mapreduceneighbors</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L79-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.simloop!-Tuple{Any,Any,Any}" href="#DynamicGrids.simloop!-Tuple{Any,Any,Any}"><code>DynamicGrids.simloop!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Loop over the selected timespan, running the ruleset and displaying the output</p><p>Operations on outputs and rulesets are allways mutable and in-place. Operations on rules and data objects are functional as they are used in inner loops where immutability improves performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/framework.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.sumneighbors" href="#DynamicGrids.sumneighbors"><code>DynamicGrids.sumneighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><p>sumneighbors(hood::Neighborhood, hoodbuffer, state)</p><p>Sums all cells in the neighborhood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/interface.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.swapsource-Tuple{DynamicGrids.SingleSimData}" href="#DynamicGrids.swapsource-Tuple{DynamicGrids.SingleSimData}"><code>DynamicGrids.swapsource</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Swap source and dest arrays. Allways returns regular SimData.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/simulationdata.jl#L150-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.updatestatus!-Tuple{Any}" href="#DynamicGrids.updatestatus!-Tuple{Any}"><code>DynamicGrids.updatestatus!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialise the block status array. This tracks whether anything has to be done in an area of the main array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/simulationdata.jl#L193-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicGrids.updatetime-Tuple{SimData,Integer}" href="#DynamicGrids.updatetime-Tuple{SimData,Integer}"><code>DynamicGrids.updatetime</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Uptate timestamp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cesaraustralia/DynamicGrids.jl/blob/deb3cdc5de993bb8197c8af43d0174d45cc5d307/src/simulationdata.jl#L161-L163">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 29 January 2020 00:23">Wednesday 29 January 2020</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
